<!DOCTYPE html>
<html>
	<head>
		<title>Lab2 part2</title>
		<!-- <script type="text/javascript" src="d3/d3.min.js"></script>  -->
		<script src="https://d3js.org/d3.v4.min.js"></script>
		<script src="textures.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.js"></script>
		<style>
			body {
			  font-family: "Helvetica Neue", Helvetica, sans-serif;
			  font-size: 14px;
			  color: #333;
			}

			path {
			  fill: #ddd;
			  stroke: #aaa;
			}

		/*	path:hover {
			  fill: orange;
			}*/

			rect:hover {
      fill: orange;
    }

		.toolTip {
  position: absolute;
  display: none;
  min-width: 80px;
  height: auto;
  background: none repeat scroll 0 0 blackfff;
  border: 1px solid #6F257F;
  padding: 14px;
  text-align: center;
}

		</style>
	</head>


	<svg width="960" height="500" id ="svg1">
	<text x=10 y=60 fill="#A20E58" onclick="population()">POPULATION</text>
	<text x=10 y=80 fill = "#A20E58" onclick="size()">size</text>
	<text x=10 y=95 fill = "#A20E58" onclick="value()">value</text>
	<text x=10 y=110 fill = "#A20E58" onclick="orientation()">orientation</text>
	<text x=10 y=125 fill = "#A20E58" onclick="color()">color</text>
	<text x=10 y=140 fill = "#A20E58" onclick="shape()">shape</text>
	<text x=10 y=155 fill = "#A20E58" onclick="texture()">texture</text>
	<text x=10 y=200 fill = "#20B2AA" onclick="area()">AREA</text>
	<text x=10 y=220 fill = "#20B2AA" onclick="size_area()">size</text>
	<text x=10 y=235 fill = "#20B2AA" onclick="value_area()">value</text>
	<text x=10 y=250 fill = "#20B2AA" onclick="orientation_area()">orientation</text>
	<text x=10 y=265 fill = "#20B2AA" onclick="color_area()">color</text>
	<text x=10 y=280 fill = "#20B2AA" onclick="shape_area()">shape</text>
	<text x=10 y=295 fill = "#20B2AA" onclick="texture_area()">texture</text>
  <text x=10 y=35 fill = "black" onclick="map()">US MAP</text>


	</svg>

	<svg width="960" height="500" id ="svg2">
		<text x=200 y=30 fill = "#A20E58" onclick="population()">show POPULATION barchart</text>
		<text x=200 y=70 fill = "#2E8B57" onclick="area()">show AREA barchart</text>
	</svg>

	<svg height="10" width="10" xmlns="http://www.w3.org/2000/svg" version="1.1"> <defs> <pattern id="circles-1" patternUnits="userSpaceOnUse" width="10" height="10"> <image xlink:href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScxMCcgaGVpZ2h0PScxMCc+CiAgPHJlY3Qgd2lkdGg9JzEwJyBoZWlnaHQ9JzEwJyBmaWxsPSJ3aGl0ZSIgLz4KICA8Y2lyY2xlIGN4PSIxIiBjeT0iMSIgcj0iMSIgZmlsbD0iYmxhY2siLz4KPC9zdmc+" x="0" y="0" width="10" height="10"> </image> </pattern> </defs> </svg>
	<body>



		</svg>


				<script>
				var margin = {top: 20, right: 80, bottom: 20, left: 80},
				    width = 960 - margin.left - margin.right,
				    height = 500 - margin.top - margin.bottom;

				var svg1 = d3.select("#svg1").append("svg")
				    .attr("width", width + margin.left + margin.right)
				    .attr("height", height + margin.top + margin.bottom)
				  	.append("g")
				    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

				var svg2 = d3.select("#svg2").append("svg")
				    .attr("width", width + margin.left + margin.right)
				    .attr("height", height + margin.top + margin.bottom)
				  	.append("g")
				    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


				map();
function map(){
	d3.select("#svg1").selectAll(".legend").remove();
	d3.select("#svg1").selectAll("circle").remove();
	d3.select("#svg1").selectAll(".point").remove();
	d3.select("#svg1").selectAll("path").remove();
	var margin = {top: 20, right: 80, bottom: 20, left: 80},
			width = 960 - margin.left - margin.right,
			height = 500 - margin.top - margin.bottom;

	var svg1 = d3.select("#svg1").append("svg")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	var svg2 = d3.select("#svg2").append("svg")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");


	d3.json("usa_mainland.json", drawUSA);

		function drawUSA(error, states) {

			var projection = d3.geoAlbersUsa()
												.translate([width / 2, height / 2]) // translate to center of screen
												.scale([1000]); // scale things down so see entire US

												// Define path generator
			var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
									 .projection(projection);
			var geoGenerator = d3.geoPath()
													.projection(projection);

		svg1.selectAll("path")
				.data(states.features)
				.enter()
				.append("path")
				.attr("d", path)
				.attr("id", function(d) {return d.properties.STUSPS10;})
				.style("stroke", "black")
				.style("stroke-width", "1");


			svg1.selectAll('text')
				.data(states.features)
				.enter()
				.append('text')
				.attr('text-anchor', 'middle')
				.attr('alignment-baseline', 'middle')
				.attr('opacity', 0.5)
				.text(function(d) {
					return d.properties.STUSPS10;
				})
				.attr('transform', function(d) {
					var center = geoGenerator.centroid(d);
					return 'translate (' + center + ')';
				});}
}

population();

function population(){
				var x = d3.scaleBand()
				    .rangeRound([0, width])
				    .paddingInner(0.05);;

				var y = d3.scaleLinear()
				    .rangeRound([height, 0]);
var tooltip = d3.select("body").append("div").attr("class", "toolTip");
	svg2.selectAll('rect').remove();
	svg2.selectAll('text').remove();
				d3.csv("population.csv", function(error, data){
							if(error){
								console.log(error)};
							console.log(data);
							data.forEach(function(d) {
    					d.population = +d.population;
  							});

								x.domain(data.map(function(d) { return d.State; }));
	  						y.domain([0, d3.max(data, function(d) { return d.population; })]);


								svg2.selectAll(".bar")
										.data(data)
										.enter().append("rect")
										.attr("class", "bar")
										.attr("x", function(d) { return x(d.State); })
										.attr("width", x.bandwidth())
										.attr("y", function(d) { return y(d.population); })
										.attr("height", function(d) { return height - y(d.population); })
										.attr("fill", "#A20E58")
										.on("mousemove", function(d){tooltip
              					.style("left", d3.event.pageX - 50 + "px")
              					.style("top", d3.event.pageY - 70 + "px")
              					.style("display", "inline-block")
              					.html(( "population:" + (d.population)));
												d3.select("#svg1").select("path#"+d.State).style("stroke","orange").style("stroke-width", "5");

											})
    					  		.on("mouseout", function(d){ tooltip.style("display", "none");
										d3.select("#svg1").selectAll('path').style("stroke", 'black').style("stroke-width", "1");
									});

				      		svg2.append("g")
				      			.attr("transform", "translate(0," + height + ")")
				      			.call(d3.axisBottom(x));
				      		svg2.append("g")
				      			.call(d3.axisLeft(y));
				      		svg2.append("text")
				      			.attr("transform", "rotate(-90)")
				      			.attr("y", 0 - margin.left)
				      			.attr("x",0 - (height / 2))
				      			.attr("dy", "1em")
				      			.style("text-anchor", "middle")
				      			.text("Population");
										svg2.append("text")
					      			.attr("y", height)
					      			.attr("x",900 - margin.right)
					      			.attr("dy", "1em")
					      			.style("text-anchor", "middle")
					      			.text("State");


					});}

					function area(){
									var x = d3.scaleBand()
									    .rangeRound([0, width])
									    .paddingInner(0.05);;

									var y = d3.scaleLinear()
									    .rangeRound([height, 0]);
					var tooltip = d3.select("body").append("div").attr("class", "toolTip");
						svg2.selectAll('rect').remove();
						svg2.selectAll('text').remove();
									d3.csv("population.csv", function(error, data){
												if(error){
													console.log(error)};
												console.log(data);
												data.forEach(function(d) {
					    					d.area = +d.area;
					  							});

													x.domain(data.map(function(d) { return d.State; }));
						  						y.domain([0, d3.max(data, function(d) { return d.area; })]);


													svg2.selectAll(".bar")
															.data(data)
															.enter().append("rect")
															.attr("class", "bar")
															.attr("x", function(d) { return x(d.State); })
															.attr("width", x.bandwidth())
															.attr("y", function(d) { return y(d.area); })
															.attr("height", function(d) { return height - y(d.area); })
															.attr("fill", "#2E8B57")
															.on("mousemove", function(d){tooltip
					              					.style("left", d3.event.pageX - 50 + "px")
					              					.style("top", d3.event.pageY - 70 + "px")
					              					.style("display", "inline-block")
					              					.html(( "area:" + (d.area)+"</br>"+"square kilometers"));
																	d3.select("#svg1").select("path#"+d.State).style("stroke","orange").style("stroke-width", "5");

																})

					    								.on("mouseout", function(d){ tooltip.style("display", "none");
															d3.select("#svg1").selectAll('path').style("stroke", 'black').style("stroke-width", "1");});

									      		svg2.append("g")
									      			.attr("transform", "translate(0," + height + ")")
									      			.call(d3.axisBottom(x));
									      		svg2.append("g")
									      			.call(d3.axisLeft(y));
									      		svg2.append("text")
									      			.attr("transform", "rotate(-90)")
									      			.attr("y", 0 - margin.left)
									      			.attr("x",0 - (height / 2))
									      			.attr("dy", "1em")
									      			.style("text-anchor", "middle")
									      			.text("Area (sq km)");
															svg2.append("text")
										      			.attr("y", height)
										      			.attr("x",900 - margin.right)
										      			.attr("dy", "1em")
										      			.style("text-anchor", "middle")
										      			.text("State");


										});}

					function value(){
							d3.select("#svg1").selectAll(".legend").remove();
						d3.select("#svg1").selectAll("circle").remove();
						d3.select("#svg1").selectAll(".point").remove();
							d3.select("#svg1").selectAll("path").remove();
					var margin = {top: 20, right: 80, bottom: 20, left: 80},
							width = 960 - margin.left - margin.right,
							height = 500 - margin.top - margin.bottom;

					var svg1 = d3.select("#svg1").append("svg")
							.attr("width", width + margin.left + margin.right)
							.attr("height", height + margin.top + margin.bottom)
							.append("g")
							.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

					var lowColor = '#e8e8e8'
					var highColor = '#000000'
					var projection = d3.geoAlbersUsa()
														.translate([width / 2, height / 2]) // translate to center of screen
														.scale([1000]); // scale things down so see entire US

														// Define path generator
					var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
											 .projection(projection);
					var geoGenerator = d3.geoPath()
															.projection(projection);


					d3.csv("population.csv", function(data) {
					  var dataArray = [];
					  for (var d = 0; d < data.length; d++) {
					    dataArray.push(parseFloat(data[d].population))
					  }
					  var minVal = d3.min(dataArray)
					  var maxVal = d3.max(dataArray)
					  var ramp = d3.scaleLinear().domain([minVal,maxVal]).range([lowColor,highColor])

					// Load GeoJSON data and merge with states data
					  d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
					  for (var i = 0; i < data.length; i++) {

					// Grab State Name
					  var dataState = data[i].State;

					// Grab data value
					  var dataValue = data[i].population;

					// Find the corresponding state inside the GeoJSON
					  for (var j = 0; j < json.features.length; j++) {
					    var jsonState = json.features[j].properties.STUSPS10;

					    if (dataState == jsonState) {

					// Copy the data value into the JSON
					    json.features[j].properties.value = dataValue;

					// Stop looking through the JSON
					    break;
					    console.log(dataValue)
					}
					}
					}

					// Bind the data to the SVG and create one path per GeoJSON feature

					svg1.selectAll("path")
					.data(json.features)
					.enter()
					.append("path")
					.attr("d", path)
					.attr("id", function(d) {return d.properties.STUSPS10;})
					.style("stroke", "black")
					.style("stroke-width", "1")
					.style("fill", function(d) { return ramp(d.properties.value) });

					svg1.selectAll('text')
						.data(json.features)
						.enter()
						.append('text')
						.attr('text-anchor', 'middle')
						.attr('alignment-baseline', 'middle')
						.attr('opacity', 0.5)
						.attr('fill', '#A20E58')
						.attr('font-weight','bold')
						.text(function(d) {
							return d.properties.STUSPS10;
						})
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						});

		var key = d3.select("#svg1")
			.append("svg")
			.attr("width", 140)
			.attr("height", 300)
			.attr("x",800)
			.attr("y",300)
			.attr("class", "legend");

		var legend = key.append("defs")
			.append("svg:linearGradient")
			.attr("class","legend")
			.attr("id", "gradient")
			.attr("x1", "100%")
			.attr("y1", "0%")
			.attr("x2", "100%")
			.attr("y2", "100%")
			.attr("spreadMethod", "pad");

		legend.append("stop")
			.attr("offset", "0%")
			.attr("stop-color", highColor)
			.attr("stop-opacity", 1);

		legend.append("stop")
			.attr("offset", "100%")
			.attr("stop-color", lowColor)
			.attr("stop-opacity", 1);

		key.append("rect")
			.attr("width", 40)
			.attr("height", 150)
			.style("fill", "url(#gradient)")
			.attr("transform", "translate(0,10)");

		var y = d3.scaleLinear()
			.range([150, 0])
			.domain([minVal, maxVal]);

		var yAxis = d3.axisRight(y);

		key.append("g")
			.attr("class", "y axis")
			.attr("transform", "translate(41,10)")
			.call(yAxis)


					});
					});
					}

					function color(){
							d3.select("#svg1").selectAll(".legend").remove();
				d3.select("#svg1").selectAll("path").remove();
				d3.select("#svg1").selectAll("rect#legend").remove();
				d3.select("#svg1").selectAll("text#legend").remove();
					var margin = {top: 20, right: 80, bottom: 20, left: 80},
							width = 960 - margin.left - margin.right,
							height = 500 - margin.top - margin.bottom;

					var svg1 = d3.select("#svg1").append("svg")
							.attr("width", width + margin.left + margin.right)
							.attr("height", height + margin.top + margin.bottom)
							.append("g")
							.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

					var projection = d3.geoAlbersUsa()
														.translate([width / 2, height / 2]) // translate to center of screen
														.scale([1000]); // scale things down so see entire US

														// Define path generator
					var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
											 .projection(projection);
					var geoGenerator = d3.geoPath()
															.projection(projection);


					d3.csv("population.csv", function(data) {
						var dataArray = [];
						for (var d = 0; d < data.length; d++) {
							dataArray.push(parseFloat(data[d].population))
						}

					// Load GeoJSON data and merge with states data
						d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
						for (var i = 0; i < data.length; i++) {

					// Grab State Name
						var dataState = data[i].State;

					// Grab data value
						var dataValue = data[i].population;

					// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

					// Copy the data value into the JSON
							json.features[j].properties.value = dataValue;

					// Stop looking through the JSON
							break;
							console.log(dataValue)
					}
					}
					}
					svg1.selectAll("path")
					.data(json.features)
					.enter()
					.append("path")
					.attr("d", path)
					.attr("id", function(d) {return d.properties.STUSPS10;})
					.style("stroke", "black")
					.style("stroke-width", "1")
					.style("fill", function(d) { if
					(d.properties.value <= 2500000) { return "#60BDBF"} else if
					((d.properties.value > 2500000)&(d.properties.value <=5000000)) { return "#9CCD60";} else if
					((d.properties.value > 5000000)&(d.properties.value <=15000000)) { return "#ffcc66";} else if
					((d.properties.value > 15000000)&(d.properties.value <=24000000)) { return "cc6633";}else if
					(d.properties.value > 24000000) { return "#CC6699";}
						});
					var color = ["#60BDBF","#9CCD60","#ffcc66","cc6633","#CC6699"];
					var population = ["<=2.5M","2.5M-5M","5M-15M","15M-24M",">=24M	"];
					var data_l = [1,2,3,4,5];

					svg1.selectAll('text')
						.data(json.features)
						.enter()
						.append('text')
						.attr('text-anchor', 'middle')
						.attr('alignment-baseline', 'middle')
						.attr('opacity', 0.5)
						.text(function(d) {
							return d.properties.STUSPS10;
						})
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						});

						var legend = svg1.selectAll(".legend")
							.data(data_l,function(d, i) { return d + i; })
							.enter().append("g")
							.attr("class", "legend")
							.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

					legend.append("rect")
							.attr("x", width-100)
							.attr("y", height-108)
							.attr("width", 18)
							.attr("height", 18)
							.style("fill", function(d, i) { return color[i]; });

					legend.append("text")
					.attr("x", width-80)
					.attr("y", height-100)
							.attr("dy", ".35em")
							.style("text-anchor", "start")
							.text(function(d, i) { return population[i]; });


					});
					});
					}

					function size(){
						d3.select("#svg1").selectAll(".legend").remove();
						d3.select("#svg1").selectAll("circle").remove();
						d3.select("#svg1").selectAll(".point").remove();
					d3.select("#svg1").selectAll("path").remove();
						var radius = d3.scaleSqrt()
	    										 .domain([0, 1e6])
	    								 		 .range([0, 5]);

					var margin = {top: 20, right: 80, bottom: 20, left: 80},
							width = 960 - margin.left - margin.right,
							height = 500 - margin.top - margin.bottom;

					var svg1 = d3.select("#svg1").append("svg")
							.attr("width", width + margin.left + margin.right)
							.attr("height", height + margin.top + margin.bottom)
							.append("g")
							.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

					var projection = d3.geoAlbersUsa()
														.translate([width / 2, height / 2]) // translate to center of screen
														.scale([1000]); // scale things down so see entire US

														// Define path generator
					var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
											 .projection(projection);
					var geoGenerator = d3.geoPath()
															.projection(projection);


					d3.csv("population.csv", function(data) {
						var dataArray = [];
						for (var d = 0; d < data.length; d++) {
							dataArray.push(parseFloat(data[d].population))
						}

					// Load GeoJSON data and merge with states data
						d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
						for (var i = 0; i < data.length; i++) {

					// Grab State Name
						var dataState = data[i].State;

					// Grab data value
						var dataValue = data[i].population;

					// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

					// Copy the data value into the JSON
							json.features[j].properties.value = dataValue;

					// Stop looking through the JSON
							break;
							console.log(dataValue)
					}
					}
					}

					// Bind the data to the SVG and create one path per GeoJSON feature

					svg1.selectAll("path")
					.data(json.features)
					.enter()
					.append("path")
					.attr("d", path)
					.attr("id", function(d) {return d.properties.STUSPS10;})
					.style("stroke", "black")
					.style("stroke-width", "1")

					svg1.append("g")
      				.attr("class", "bubble")
    					.selectAll("circle")
      				.data(json.features)
    					.enter().append("circle")
							.attr('transform', function(d) {
								var center = geoGenerator.centroid(d);
								return 'translate (' + center + ')';
							})
      				.attr("r", function(d) { return radius(d.properties.value);})
							.attr("fill", "#A20E58");

					});
					});
					}

					function shape(){
							d3.select("#svg1").selectAll(".legend").remove();
						d3.select("#svg1").selectAll("circle").remove();
						d3.select("#svg1").selectAll(".point").remove();
						d3.select("#svg1").selectAll("path").remove();
					var margin = {top: 20, right: 80, bottom: 20, left: 80},
							width = 960 - margin.left - margin.right,
							height = 500 - margin.top - margin.bottom;

					var svg1 = d3.select("#svg1").append("svg")
							.attr("width", width + margin.left + margin.right)
							.attr("height", height + margin.top + margin.bottom)
							.append("g")
							.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

					var projection = d3.geoAlbersUsa()
														.translate([width / 2, height / 2]) // translate to center of screen
														.scale([1000]); // scale things down so see entire US

														// Define path generator
					var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
											 .projection(projection);
					var geoGenerator = d3.geoPath()
															.projection(projection);


					d3.csv("population.csv", function(data) {
						var dataArray = [];
						for (var d = 0; d < data.length; d++) {
							dataArray.push(parseFloat(data[d].population))
						}

					// Load GeoJSON data and merge with states data
						d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
						for (var i = 0; i < data.length; i++) {

					// Grab State Name
						var dataState = data[i].State;

					// Grab data value
						var dataValue = data[i].population;

					// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

					// Copy the data value into the JSON
							json.features[j].properties.value = dataValue;

					// Stop looking through the JSON
							break;
							console.log(dataValue)
					}
					}
					}

					// Bind the data to the SVG and create one path per GeoJSON feature

					svg1.selectAll("path")
					.data(json.features)
					.enter()
					.append("path")
					.attr("id", function(d) {return d.properties.STUSPS10;})
					.attr("d", path)
					.style("stroke", "black")
					.style("stroke-width", "1")


					svg1.selectAll(".point")
      				.data(json.features)
							.enter()
							.append("path")
							.attr("d", path)
  						.attr("d", d3.symbol()
							.size(100)
							.type(function(d) { if
							(d.properties.value <= 2500000) { return d3.symbolWye;} else if
							((d.properties.value > 2500000)&(d.properties.value <=5000000)) { return d3.symbolCross;} else if
							((d.properties.value > 5000000)&(d.properties.value <=15000000)) { return d3.symbolTriangle;} else if
							((d.properties.value > 15000000)&(d.properties.value <=24000000)) { return d3.symbolDiamond;}else if
							(d.properties.value > 24000000) { return d3.symbolStar;}}))
							.attr('transform', function(d) {
								var center = geoGenerator.centroid(d);
								return 'translate (' + center + ')';
							})
							.style("fill", "#A20E58")
							.style('stroke','black')
							.style('stoke-width','1');

							var population = ["<=2.5M","2.5M-5M","5M-15M","15M-24M",">=24M	"];
							var data_l = [1,2,3,4,5];
							var symbolLegend = [d3.symbolWye, d3.symbolCross,d3.symbolTriangle,d3.symbolDiamond,d3.symbolStar];

							var legend = svg1.selectAll(".legend")
								.data(data_l,function(d, i) { return d + i; })
								.enter().append("g")
								.attr("class", "legend")
								.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });


								var triangleU = d3.symbol().type(d3.symbolWye)(),
								circle = d3.symbol().type(d3.symbolCross)(),
								cross = d3.symbol().type(d3.symbolTriangle)(),
								diamond = d3.symbol().type(d3.symbolDiamond)(),
								star = d3.symbol().type(d3.symbolStar)();

								var symbolScale =  d3.scaleOrdinal()
								.domain(population)
								.range([ triangleU, circle, cross, diamond, star] );

								var svg = d3.select("#svg1")
								.append("svg")
								.attr("width", 140)
								.attr("height", 300)
								.attr("x",760)
								.attr("y",350)
								.attr("class", "legend");


								svg.append("g")
								.attr("class", "legend")
								.attr("transform", "translate(20, 20)");

								var legendPath = d3.legendSymbol()
								.scale(symbolScale)
								.orient("vertical")
								.labelWrap(100);

								svg.select(".legend")
								.call(legendPath);


					});
					});
					}

					function texture(){
							d3.select("#svg1").selectAll(".legend").remove();
						d3.select("#svg1").selectAll("circle").remove();
						d3.select("#svg1").selectAll(".point").remove();
						d3.select("#svg1").selectAll("path").remove();

					var margin = {top: 20, right: 80, bottom: 20, left: 80},
							width = 960 - margin.left - margin.right,
							height = 500 - margin.top - margin.bottom;

					var svg1 = d3.select("#svg1").append("svg")
							.attr("width", width + margin.left + margin.right)
							.attr("height", height + margin.top + margin.bottom)
							.append("g")
							.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

							var orange = '#ff8c00',
			 navy = '#0d3268';

	 // defined textures
	 var t5 = textures.lines()
			 .orientation("6/8");

var t3= textures.paths()
  .d("crosses")
  .lighter()
  .thicker();

var t4 =textures.paths()
  .d("hexagons")
  .size(8)
  .strokeWidth(2);

	 var t2 = textures.circles()
			 .size(10)
			 .radius(1.5);
	 var t1 = textures.paths()
			 .d("waves")
			 .thicker();

	 // add all textures to an array
	 var tlist = [t1, t2, t3, t4, t5];

					var projection = d3.geoAlbersUsa()
														.translate([width / 2, height / 2]) // translate to center of screen
														.scale([1000]); // scale things down so see entire US

														// Define path generator
					var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
											 .projection(projection);
					var geoGenerator = d3.geoPath()
															.projection(projection);


					d3.csv("population.csv", function(data) {
						var dataArray = [];
						for (var d = 0; d < data.length; d++) {
							dataArray.push(parseFloat(data[d].population))
						}

					// Load GeoJSON data and merge with states data
						d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
						for (var i = 0; i < data.length; i++) {

					// Grab State Name
						var dataState = data[i].State;

					// Grab data value
						var dataValue = data[i].population;

					// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

					// Copy the data value into the JSON
							json.features[j].properties.value = dataValue;

					// Stop looking through the JSON
							break;
							console.log(dataValue)
					}
					}
					}
					tlist.forEach(function(t) {
        svg1.call(t);
    });

					svg1.selectAll("path")
					.data(json.features, function(d, i) { return d + i; })
					.enter()
					.append("path")
					.attr("d", path)
					.attr("id", function(d) {return d.properties.STUSPS10;})
					.style("stroke", "#000")
					.style("stroke-width", "1")
					.style("fill", function(d) { if
					(d.properties.value <= 2500000) { return t1.url();} else if
					((d.properties.value > 2500000)&(d.properties.value <=5000000)) { return t4.url();} else if
					((d.properties.value > 5000000)&(d.properties.value <=15000000)) { return t3.url();} else if
					((d.properties.value > 15000000)&(d.properties.value <=24000000)) { return t2.url();}else if
					(d.properties.value > 24000000) { return t5.url();}
						});


					svg1.selectAll('text')
						.data(json.features)
						.enter()
						.append('text')
						.attr('text-anchor', 'middle')
						.attr('alignment-baseline', 'middle')
						.attr('opacity', 0.5)
						.text(function(d) {
							return d.properties.STUSPS10;
						})
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						});
						var population = ["<=2.5M","2.5M-5M","5M-15M","15M-24M",">=24M	"];
						var data_l = [1,2,3,4,5];
						var legend = svg1.selectAll(".legend")
							.data(data_l,function(d, i) { return d + i; })
							.enter().append("g")
							.attr("class", "legend")
							.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

					legend.append("rect")
							.attr("id", "legend")
							.attr("x", width-100)
							.attr("y", height-108)
							.attr("width", 18)
							.attr("height", 18)
							.style("fill", function(d, i) { return tlist[i].url(); })
							.style("stroke", "#000")
							.style("stroke-width", "1");

					legend.append("text")
					.attr("id","legend")
					.attr("x", width-75)
					.attr("y", height-100)
							.attr("dy", ".35em")
							.style("text-anchor", "start")
							.text(function(d, i) { return population[i]; });

					});
					});
					}

					function orientation(){
						d3.select("#svg1").selectAll(".legend").remove();
						d3.select("#svg1").selectAll("circle").remove();
						d3.select("#svg1").selectAll(".point").remove();
				d3.select("#svg1").selectAll("path").remove();

					var margin = {top: 20, right: 80, bottom: 20, left: 80},
							width = 960 - margin.left - margin.right,
							height = 500 - margin.top - margin.bottom;

					var svg1 = d3.select("#svg1").append("svg")
							.attr("width", width + margin.left + margin.right)
							.attr("height", height + margin.top + margin.bottom)
							.append("g")
							.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	 // defined textures
	 var t1 = textures.lines()
	     .thicker()
	 		 .orientation("horizontal");
	 var t2 = textures.lines()
	 		 .thicker()
			 .orientation("1/8");
	 var t3 = textures.lines()
	 		 .thicker()
	 		 .orientation("2/8");
	 var t4 = textures.lines()
	 		 .thicker()
			 .orientation("3/8");
	 var t5 = textures.lines()
	 		 .thicker()
	 		 .orientation("5/8");
	 var t6 = textures.lines()
	 		 .thicker()
			 .orientation("5/8");
	 var t7 = textures.lines()
	 		 .thicker()
			 .orientation("6/8");
	 var t8 = textures.lines()
	 		 .thicker()
			 .orientation("7/8");
	 var t9 = textures.lines()
	 		 .thicker()
			 .orientation("vertical");
	 // add all textures to an array
	 var tlist = [t1, t2, t3, t4, t5, t6, t7,t8,t9];

					var projection = d3.geoAlbersUsa()
														.translate([width / 2, height / 2]) // translate to center of screen
														.scale([1000]); // scale things down so see entire US

														// Define path generator
					var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
											 .projection(projection);
					var geoGenerator = d3.geoPath()
															.projection(projection);


					d3.csv("population.csv", function(data) {
						var dataArray = [];
						for (var d = 0; d < data.length; d++) {
							dataArray.push(parseFloat(data[d].population))
						}

					// Load GeoJSON data and merge with states data
						d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
						for (var i = 0; i < data.length; i++) {

					// Grab State Name
						var dataState = data[i].State;

					// Grab data value
						var dataValue = data[i].population;

					// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

					// Copy the data value into the JSON
							json.features[j].properties.value = dataValue;

					// Stop looking through the JSON
							break;
							console.log(dataValue)
					}
					}
					}
					tlist.forEach(function(t) {
				svg1.call(t);
		});

					svg1.selectAll("path")
					.data(json.features, function(d, i) { return d + i; })
					.enter()
					.append("path")
					.attr("d", path)
					.attr("id", function(d) {return d.properties.STUSPS10;})
					.style("stroke", "#000")
					.style("stroke-width", "1")
					.style("fill", function(d) { if
					(d.properties.value <= 2500000) { return t1.url();} else if
					((d.properties.value > 2500000)&(d.properties.value <=5000000)) { return t2.url();} else if
					((d.properties.value > 5000000)&(d.properties.value <=15000000)) { return t3.url();} else if
					((d.properties.value > 15000000)&(d.properties.value <=24000000)) { return t4.url();}else if
					(d.properties.value > 24000000) { return t5.url();}
						});

					svg1.selectAll('text')
						.data(json.features)
						.enter()
						.append('text')
						.attr('text-anchor', 'middle')
						.attr('alignment-baseline', 'middle')
						.attr('opacity', 0.5)
						.text(function(d) {
							return d.properties.STUSPS10;
						})
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						});

						var population = ["<=2.5M","2.5M-5M","5M-15M","15M-24M",">=24M	"];
						var data_l = [1,2,3,4,5];
						var legend = svg1.selectAll(".legend")
							.data(data_l,function(d, i) { return d + i; })
							.enter().append("g")
							.attr("class", "legend")
							.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

					legend.append("rect")
							.attr("x", width-100)
							.attr("y", height-108)
							.attr("id","legend")
							.attr("width", 18)
							.attr("height", 18)
							.style("fill", function(d, i) { return tlist[i].url(); })
							.style("stroke", "#000")
							.style("stroke-width", "1");

					legend.append("text")
					.attr("x", width-75)
					.attr("y", height-100)
					.attr("id","legend")
							.attr("dy", ".35em")
							.style("text-anchor", "start")
							.text(function(d, i) { return population[i]; });

					});
					});
					}




										function value_area(){
												d3.select("#svg1").selectAll(".legend").remove();
											d3.select("#svg1").selectAll("circle").remove();
											d3.select("#svg1").selectAll(".point").remove();
											d3.select("#svg1").selectAll("path").remove();

										var margin = {top: 20, right: 80, bottom: 20, left: 80},
												width = 960 - margin.left - margin.right,
												height = 500 - margin.top - margin.bottom;

										var svg1 = d3.select("#svg1").append("svg")
												.attr("width", width + margin.left + margin.right)
												.attr("height", height + margin.top + margin.bottom)
												.append("g")
												.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

										var lowColor = '#e8e8e8'
										var highColor = '#000000'
										var projection = d3.geoAlbersUsa()
																			.translate([width / 2, height / 2]) // translate to center of screen
																			.scale([1000]); // scale things down so see entire US

																			// Define path generator
										var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
																 .projection(projection);
										var geoGenerator = d3.geoPath()
																				.projection(projection);


										d3.csv("population.csv", function(data) {
										  var dataArray = [];
										  for (var d = 0; d < data.length; d++) {
										    dataArray.push(parseFloat(data[d].area))
										  }
										  var minVal = d3.min(dataArray)
										  var maxVal = d3.max(dataArray)
										  var ramp = d3.scaleLinear().domain([minVal,maxVal]).range([lowColor,highColor])

										// Load GeoJSON data and merge with states data
										  d3.json("usa_mainland.json", function(json) {

										// Loop through each state data value in the .csv file
										  for (var i = 0; i < data.length; i++) {

										// Grab State Name
										  var dataState = data[i].State;

										// Grab data value
										  var dataValue = data[i].area;

										// Find the corresponding state inside the GeoJSON
										  for (var j = 0; j < json.features.length; j++) {
										    var jsonState = json.features[j].properties.STUSPS10;

										    if (dataState == jsonState) {

										// Copy the data value into the JSON
										    json.features[j].properties.value = dataValue;

										// Stop looking through the JSON
										    break;
										    console.log(dataValue)
										}
										}
										}

										// Bind the data to the SVG and create one path per GeoJSON feature

										svg1.selectAll("path")
										.data(json.features)
										.enter()
										.append("path")
										.attr("d", path)
										.attr("id", function(d) {return d.properties.STUSPS10;})
										.style("stroke", "black")
										.style("stroke-width", "1")
										.style("fill", function(d) { return ramp(d.properties.value) });

										svg1.selectAll('text')
											.data(json.features)
											.enter()
											.append('text')
											.attr('fill','#087851')
											.attr('font-weight','bold')
											.attr('text-anchor', 'middle')
											.attr('alignment-baseline', 'middle')
											.attr('opacity', 0.5)
											.text(function(d) {
												return d.properties.STUSPS10;
											})
											.attr('transform', function(d) {
												var center = geoGenerator.centroid(d);
												return 'translate (' + center + ')';
											});

											var key = d3.select("#svg1")
												.append("svg")
												.attr("width", 140)
												.attr("height", 300)
												.attr("x",800)
												.attr("y",300)
												.attr("class", "legend");

											var legend = key.append("defs")
												.append("svg:linearGradient")
												.attr("class","legend")
												.attr("id", "gradient")
												.attr("x1", "100%")
												.attr("y1", "0%")
												.attr("x2", "100%")
												.attr("y2", "100%")
												.attr("spreadMethod", "pad");

											legend.append("stop")
												.attr("offset", "0%")
												.attr("stop-color", highColor)
												.attr("stop-opacity", 1);

											legend.append("stop")
												.attr("offset", "100%")
												.attr("stop-color", lowColor)
												.attr("stop-opacity", 1);

											key.append("rect")
												.attr("width", 40)
												.attr("height", 150)
												.style("fill", "url(#gradient)")
												.attr("transform", "translate(0,10)");

											var y = d3.scaleLinear()
												.range([150, 0])
												.domain([minVal, maxVal]);

											var yAxis = d3.axisRight(y);

											key.append("g")
												.attr("class", "y axis")
												.attr("transform", "translate(41,10)")
												.call(yAxis)

										});
										});
										}

										function color_area(){
												d3.select("#svg1").selectAll(".legend").remove();
											d3.select("#svg1").selectAll("circle").remove();
											d3.select("#svg1").selectAll(".point").remove();
											d3.select("#svg1").selectAll("path").remove();

										var margin = {top: 20, right: 80, bottom: 20, left: 80},
												width = 960 - margin.left - margin.right,
												height = 500 - margin.top - margin.bottom;

										var svg1 = d3.select("#svg1").append("svg")
												.attr("width", width + margin.left + margin.right)
												.attr("height", height + margin.top + margin.bottom)
												.append("g")
												.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

										var projection = d3.geoAlbersUsa()
																			.translate([width / 2, height / 2]) // translate to center of screen
																			.scale([1000]); // scale things down so see entire US

																			// Define path generator
										var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
																 .projection(projection);
										var geoGenerator = d3.geoPath()
																				.projection(projection);


										d3.csv("population.csv", function(data) {
											var dataArray = [];
											for (var d = 0; d < data.length; d++) {
												dataArray.push(parseFloat(data[d].area))
											}

										// Load GeoJSON data and merge with states data
											d3.json("usa_mainland.json", function(json) {

										// Loop through each state data value in the .csv file
											for (var i = 0; i < data.length; i++) {

										// Grab State Name
											var dataState = data[i].State;

										// Grab data value
											var dataValue = data[i].area;

										// Find the corresponding state inside the GeoJSON
											for (var j = 0; j < json.features.length; j++) {
												var jsonState = json.features[j].properties.STUSPS10;

												if (dataState == jsonState) {

										// Copy the data value into the JSON
												json.features[j].properties.value = dataValue;

										// Stop looking through the JSON
												break;
												console.log(dataValue)
										}
										}
										}

										// Bind the data to the SVG and create one path per GeoJSON feature

										svg1.selectAll("path")
										.data(json.features)
										.enter()
										.append("path")
										.attr("d", path)
										.attr("id", function(d) {return d.properties.STUSPS10;})
										.style("stroke", "black")
										.style("stroke-width", "1")
										.style("fill", function(d) { if
										(d.properties.value <= 100000) { return "#60BDBF"} else if
										((d.properties.value > 100000)&(d.properties.value <=200000)) { return "#9CCD60";} else if
										((d.properties.value > 200000)&(d.properties.value <=300000)) { return "#ffcc66";} else if
										((d.properties.value > 300000)&(d.properties.value <=400000)) { return "cc6633";}else if
										(d.properties.value > 400000) { return "#CC6699";}
											});

										svg1.selectAll('text')
											.data(json.features)
											.enter()
											.append('text')
											.attr('text-anchor', 'middle')
											.attr('alignment-baseline', 'middle')
											.attr('opacity', 0.5)
											.text(function(d) {
												return d.properties.STUSPS10;
											})
											.attr('transform', function(d) {
												var center = geoGenerator.centroid(d);
												return 'translate (' + center + ')';
											});
											var color = ["#60BDBF","#9CCD60","#ffcc66","cc6633","#CC6699"];
												var area = ["<=0.1M sq km","0.1M-0.2M","0.2M-0.3M","0.3M-0.4M",">=0.4M	"];
											var data_l = [1,2,3,4,5];

											var legend = svg1.selectAll(".legend")
												.data(data_l,function(d, i) { return d + i; })
												.enter().append("g")
												.attr("class", "legend")
												.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

										legend.append("rect")
												.attr("x", width-100)
												.attr("y", height-108)
												.attr("width", 18)
												.attr("height", 18)
												.style("fill", function(d, i) { return color[i]; });

										legend.append("text")
										.attr("x", width-80)
										.attr("y", height-100)
												.attr("dy", ".35em")
												.style("text-anchor", "start")
												.text(function(d, i) { return area[i]; });



										});
										});
										}

										function size_area(){
												d3.select("#svg1").selectAll(".legend").remove();
											d3.select("#svg1").selectAll("circle").remove();
											d3.select("#svg1").selectAll(".point").remove();
											d3.select("#svg1").selectAll("path").remove();
											var radius = d3.scaleSqrt()
						    										 .domain([0, 1730000])
						    								 		 .range([0, 40]);

										var margin = {top: 20, right: 80, bottom: 20, left: 80},
												width = 960 - margin.left - margin.right,
												height = 500 - margin.top - margin.bottom;

										var svg1 = d3.select("#svg1").append("svg")
												.attr("width", width + margin.left + margin.right)
												.attr("height", height + margin.top + margin.bottom)
												.append("g")
												.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

										var projection = d3.geoAlbersUsa()
																			.translate([width / 2, height / 2]) // translate to center of screen
																			.scale([1000]); // scale things down so see entire US

																			// Define path generator
										var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
																 .projection(projection);
										var geoGenerator = d3.geoPath()
																				.projection(projection);


										d3.csv("population.csv", function(data) {
											var dataArray = [];
											for (var d = 0; d < data.length; d++) {
												dataArray.push(parseFloat(data[d].area))
											}

										// Load GeoJSON data and merge with states data
											d3.json("usa_mainland.json", function(json) {

										// Loop through each state data value in the .csv file
											for (var i = 0; i < data.length; i++) {

										// Grab State Name
											var dataState = data[i].State;

										// Grab data value
											var dataValue = data[i].area;

										// Find the corresponding state inside the GeoJSON
											for (var j = 0; j < json.features.length; j++) {
												var jsonState = json.features[j].properties.STUSPS10;

												if (dataState == jsonState) {

										// Copy the data value into the JSON
												json.features[j].properties.value = dataValue;

										// Stop looking through the JSON
												break;
												console.log(dataValue)
										}
										}
										}

										// Bind the data to the SVG and create one path per GeoJSON feature

										svg1.selectAll("path")
										.data(json.features)
										.enter()
										.append("path")
										.attr("d", path)
										.attr("id", function(d) {return d.properties.STUSPS10;})
										.style("stroke", "black")
										.style("stroke-width", "1")

										svg1.append("g")
					      				.attr("class", "bubble")
					    					.selectAll("circle")
					      				.data(json.features)
					    					.enter().append("circle")
												.attr('transform', function(d) {
													var center = geoGenerator.centroid(d);
													return 'translate (' + center + ')';
												})
					      				.attr("r", function(d) { return radius(d.properties.value);})
												.attr("fill", "#2E8B57");

										});
										});
										}

										function shape_area(){
												d3.select("#svg1").selectAll(".legend").remove();
											d3.select("#svg1").selectAll("circle").remove();
											d3.select("#svg1").selectAll(".point").remove();
											d3.select("#svg1").selectAll("path").remove();
										var margin = {top: 20, right: 80, bottom: 20, left: 80},
												width = 960 - margin.left - margin.right,
												height = 500 - margin.top - margin.bottom;

										var svg1 = d3.select("#svg1").append("svg")
												.attr("width", width + margin.left + margin.right)
												.attr("height", height + margin.top + margin.bottom)
												.append("g")
												.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

										var projection = d3.geoAlbersUsa()
																			.translate([width / 2, height / 2]) // translate to center of screen
																			.scale([1000]); // scale things down so see entire US

																			// Define path generator
										var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
																 .projection(projection);
										var geoGenerator = d3.geoPath()
																				.projection(projection);


										d3.csv("population.csv", function(data) {
											var dataArray = [];
											for (var d = 0; d < data.length; d++) {
												dataArray.push(parseFloat(data[d].area))
											}

										// Load GeoJSON data and merge with states data
											d3.json("usa_mainland.json", function(json) {

										// Loop through each state data value in the .csv file
											for (var i = 0; i < data.length; i++) {

										// Grab State Name
											var dataState = data[i].State;

										// Grab data value
											var dataValue = data[i].area;

										// Find the corresponding state inside the GeoJSON
											for (var j = 0; j < json.features.length; j++) {
												var jsonState = json.features[j].properties.STUSPS10;

												if (dataState == jsonState) {

										// Copy the data value into the JSON
												json.features[j].properties.value = dataValue;

										// Stop looking through the JSON
												break;
												console.log(dataValue)
										}
										}
										}

										// Bind the data to the SVG and create one path per GeoJSON feature

										svg1.selectAll("path")
										.data(json.features)
										.enter()
										.append("path")
										.attr("d", path)
										.attr("id", function(d) {return d.properties.STUSPS10;})
										.style("stroke", "black")
										.style("stroke-width", "1")


										svg1.selectAll(".point")
												.data(json.features)
												.enter()
												.append("path")
												.attr("d", path)
												.attr("d", d3.symbol()
												.size(100)
												.type(function(d) { if
												(d.properties.value <= 100000) { return d3.symbolWye;} else if
												((d.properties.value > 100000)&(d.properties.value <=200000)) { return d3.symbolCross;} else if
												((d.properties.value > 200000)&(d.properties.value <=300000)) { return d3.symbolTriangle;} else if
												((d.properties.value > 300000)&(d.properties.value <=400000)) { return d3.symbolDiamond;}else if
												(d.properties.value > 400000) { return d3.symbolStar;}}))
												.attr('transform', function(d) {
													var center = geoGenerator.centroid(d);
													return 'translate (' + center + ')';
												})
												.style("fill", "#20B2AA")
												.style('stroke','black')
												.style('stoke-width','1');
												var area = ["<=0.1M sq km","0.1M-0.2M","0.2M-0.3M","0.3M-0.4M",">=0.4M	"];
												var data_l = [1,2,3,4,5];
												var symbolLegend = [d3.symbolWye, d3.symbolCross,d3.symbolTriangle,d3.symbolDiamond,d3.symbolStar];

												var legend = svg1.selectAll(".legend")
													.data(data_l,function(d, i) { return d + i; })
													.enter().append("g")
													.attr("class", "legend")
													.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });


													var triangleU = d3.symbol().type(d3.symbolWye)(),
  												circle = d3.symbol().type(d3.symbolCross)(),
  												cross = d3.symbol().type(d3.symbolTriangle)(),
  												diamond = d3.symbol().type(d3.symbolDiamond)(),
  												star = d3.symbol().type(d3.symbolStar)();

													var symbolScale =  d3.scaleOrdinal()
  												.domain(area)
  												.range([ triangleU, circle, cross, diamond, star] );

													var svg = d3.select("#svg1")
													.append("svg")
													.attr("width", 140)
													.attr("height", 300)
													.attr("x",760)
													.attr("y",350)
													.attr("class", "legend");

													svg.append("g")
  												.attr("class", "legend")
  												.attr("transform", "translate(20, 20)");

													var legendPath = d3.legendSymbol()
  												.scale(symbolScale)
  												.orient("vertical")
  												.labelWrap(100);

													svg.select(".legend")
  											.call(legendPath);


										});
										});
										}

										function texture_area(){
												d3.select("#svg1").selectAll(".legend").remove();
											d3.select("#svg1").selectAll("circle").remove();
											d3.select("#svg1").selectAll(".point").remove();
											d3.select("#svg1").selectAll("path").remove();

										var margin = {top: 20, right: 80, bottom: 20, left: 80},
												width = 960 - margin.left - margin.right,
												height = 500 - margin.top - margin.bottom;

										var svg1 = d3.select("#svg1").append("svg")
												.attr("width", width + margin.left + margin.right)
												.attr("height", height + margin.top + margin.bottom)
												.append("g")
												.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

												var orange = '#ff8c00',
										navy = '#0d3268';

										// defined textures
										var t5 = textures.lines()
								 			 .orientation("6/8");

								 var t3= textures.paths().
								 d("crosses")
							   .lighter()
							   .thicker();

								 var t4 =textures.paths()
								   .d("hexagons")
								   .size(8)
								   .strokeWidth(2);

								 	 var t2 = textures.circles()
								 			 .size(10)
								 			 .radius(1.5);
								 	 var t1 = textures.paths()
								 			 .d("waves")
								 			 .thicker();


										// add all textures to an array
										var tlist = [t1, t2, t3, t4, t5];

										var projection = d3.geoAlbersUsa()
																			.translate([width / 2, height / 2]) // translate to center of screen
																			.scale([1000]); // scale things down so see entire US

																			// Define path generator
										var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
																 .projection(projection);
										var geoGenerator = d3.geoPath()
																				.projection(projection);


										d3.csv("population.csv", function(data) {
											var dataArray = [];
											for (var d = 0; d < data.length; d++) {
												dataArray.push(parseFloat(data[d].area))
											}

										// Load GeoJSON data and merge with states data
											d3.json("usa_mainland.json", function(json) {

										// Loop through each state data value in the .csv file
											for (var i = 0; i < data.length; i++) {

										// Grab State Name
											var dataState = data[i].State;

										// Grab data value
											var dataValue = data[i].area;

										// Find the corresponding state inside the GeoJSON
											for (var j = 0; j < json.features.length; j++) {
												var jsonState = json.features[j].properties.STUSPS10;

												if (dataState == jsonState) {

										// Copy the data value into the JSON
												json.features[j].properties.value = dataValue;

										// Stop looking through the JSON
												break;
												console.log(dataValue)
										}
										}
										}
										tlist.forEach(function(t) {
										svg1.call(t);
										});

										svg1.selectAll("path")
										.data(json.features, function(d, i) { return d + i; })
										.enter()
										.append("path")
										.attr("d", path)
										.attr("id", function(d) {return d.properties.STUSPS10;})
										.style("stroke", "#000")
										.style("stroke-width", "1")
										.style("fill", function(d) { if
										(d.properties.value <= 100000) { return t1.url();} else if
										((d.properties.value > 100000)&(d.properties.value <=200000)) { return t4.url();} else if
										((d.properties.value > 200000)&(d.properties.value <=300000)) { return t3.url();} else if
										((d.properties.value > 300000)&(d.properties.value <=400000)) { return t2.url();}else if
										(d.properties.value > 400000) { return t5.url();}
											});


										svg1.selectAll('text')
											.data(json.features)
											.enter()
											.append('text')
											.attr('text-anchor', 'middle')
											.attr('alignment-baseline', 'middle')
											.attr('opacity', 0.5)
											.text(function(d) {
												return d.properties.STUSPS10;
											})
											.attr('transform', function(d) {
												var center = geoGenerator.centroid(d);
												return 'translate (' + center + ')';
											});

											var area = ["<=0.1M sq km","0.1M-0.2M","0.2M-0.3M","0.3M-0.4M",">=0.4M	"];
											var data_l = [1,2,3,4,5];
											var legend = svg1.selectAll(".legend")
												.data(data_l,function(d, i) { return d + i; })
												.enter().append("g")
												.attr("class", "legend")
												.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

										legend.append("rect")
												.attr("x", width-100)
												.attr("y", height-108)
												.attr("id","legend")
												.attr("width", 18)
												.attr("height", 18)
												.style("fill", function(d, i) { return tlist[i].url(); })
												.style("stroke", "#000")
												.style("stroke-width", "1");

										legend.append("text")
										.attr("x", width-75)
										.attr("y", height-100)
										.attr("id","legend")
												.attr("dy", ".35em")
												.style("text-anchor", "start")
												.text(function(d, i) { return area[i]; });


										});
										});
										}


										function orientation_area(){
												d3.select("#svg1").selectAll(".legend").remove();
											d3.select("#svg1").selectAll("circle").remove();
											d3.select("#svg1").selectAll(".point").remove();
											d3.select("#svg1").selectAll("path").remove();
										var margin = {top: 20, right: 80, bottom: 20, left: 80},
												width = 960 - margin.left - margin.right,
												height = 500 - margin.top - margin.bottom;

										var svg1 = d3.select("#svg1").append("svg")
												.attr("width", width + margin.left + margin.right)
												.attr("height", height + margin.top + margin.bottom)
												.append("g")
												.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

										// defined textures
										var t1 = textures.lines()
										.thicker()
										.orientation("horizontal");
										var t2 = textures.lines()
										.thicker()
										.orientation("1/8");
										var t3 = textures.lines()
										.thicker()
										.orientation("2/8");
										var t4 = textures.lines()
										.thicker()
										.orientation("3/8");
										var t5 = textures.lines()
										.thicker()
										.orientation("5/8");
										var t6 = textures.lines()
										.thicker()
										.orientation("5/8");
										var t7 = textures.lines()
										.thicker()
										.orientation("6/8");
										var t8 = textures.lines()
										.thicker()
										.orientation("7/8");
										var t9 = textures.lines()
										.thicker()
										.orientation("vertical");
										// add all textures to an array
										var tlist = [t1, t2, t3, t4, t5, t6, t7,t8,t9];

										var projection = d3.geoAlbersUsa()
																			.translate([width / 2, height / 2]) // translate to center of screen
																			.scale([1000]); // scale things down so see entire US

																			// Define path generator
										var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
																 .projection(projection);
										var geoGenerator = d3.geoPath()
																				.projection(projection);


										d3.csv("population.csv", function(data) {
											var dataArray = [];
											for (var d = 0; d < data.length; d++) {
												dataArray.push(parseFloat(data[d].area))
											}

										// Load GeoJSON data and merge with states data
											d3.json("usa_mainland.json", function(json) {

										// Loop through each state data value in the .csv file
											for (var i = 0; i < data.length; i++) {

										// Grab State Name
											var dataState = data[i].State;

										// Grab data value
											var dataValue = data[i].area;

										// Find the corresponding state inside the GeoJSON
											for (var j = 0; j < json.features.length; j++) {
												var jsonState = json.features[j].properties.STUSPS10;

												if (dataState == jsonState) {

										// Copy the data value into the JSON
												json.features[j].properties.value = dataValue;

										// Stop looking through the JSON
												break;
												console.log(dataValue)
										}
										}
										}
										tlist.forEach(function(t) {
										svg1.call(t);
										});

										svg1.selectAll("path")
										.data(json.features, function(d, i) { return d + i; })
										.enter()
										.append("path")
										.attr("d", path)
										.attr("id", function(d) {return d.properties.STUSPS10;})
										.style("stroke", "#000")
										.style("stroke-width", "1")
										.style("fill", function(d) { if
										(d.properties.value <= 100000) { return t5.url();} else if
										((d.properties.value > 100000)&(d.properties.value <=200000)) { return t1.url();} else if
										((d.properties.value > 200000)&(d.properties.value <=300000)) { return t2.url();} else if
										((d.properties.value > 300000)&(d.properties.value <=400000)) { return t9.url();}else if
										(d.properties.value > 400000) { return t7.url();}
											});


										svg1.selectAll('text')
											.data(json.features)
											.enter()
											.append('text')
											.attr('text-anchor', 'middle')
											.attr('alignment-baseline', 'middle')
											.attr('opacity', 0.5)
											.text(function(d) {
												return d.properties.STUSPS10;
											})
											.attr('transform', function(d) {
												var center = geoGenerator.centroid(d);
												return 'translate (' + center + ')';
											});

											var area = ["<=0.1M sq km","0.1M-0.2M","0.2M-0.3M","0.3M-0.4M",">=0.4M	"];
											var data_l = [1,2,3,4,5];
											var legend = svg1.selectAll(".legend")
												.data(data_l,function(d, i) { return d + i; })
												.enter().append("g")
												.attr("class", "legend")
												.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

										legend.append("rect")
												.attr("x", width-100)
												.attr("y", height-108)
												.attr("id", "legend")
												.attr("width", 18)
												.attr("height", 18)
												.style("fill", function(d, i) { return tlist[i].url(); })
												.style("stroke", "#000")
												.style("stroke-width", "1");

										legend.append("text")
										.attr("x", width-75)
										.attr("y", height-100)
										.attr("id", legend)
												.attr("dy", ".35em")
												.style("text-anchor", "start")
												.text(function(d, i) { return area[i]; });

										});
										});
										}



					</script>
</html>
