<!DOCTYPE html>
<html>

<head>
	<title>Lab2 part2</title>
	<!-- <script type="text/javascript" src="d3/d3.min.js"></script>  -->
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="textures.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.js"></script>
	<style>
		body {
			font-family: "Helvetica Neue", Helvetica, sans-serif;
			font-size: 14px;
			color: #333;
		}

		path {
			fill: #ddd;
			stroke: #aaa;
		}

		/*	path:hover {
			  fill: orange;
			}*/

		rect:hover {
			fill: orange;
		}

		.toolTip {
			position: absolute;
			display: none;
			min-width: 80px;
			height: auto;
			background: none repeat scroll 0 0 blackfff;
			border: 1px solid #6F257F;
			padding: 14px;
			text-align: center;
		}
	</style>
</head>


<svg width="960" height="500" id="svg1">
	<text x=10 y=60 fill="#A20E58" onclick="population()">POPULATION</text>
	<text x=10 y=80 fill="#A20E58" onclick="size()">size</text>
	<text x=10 y=95 fill="#A20E58" onclick="value()">value</text>
	<text x=10 y=110 fill="#A20E58" onclick="orientation()">orientation</text>
	<text x=10 y=125 fill="#A20E58" onclick="color()">color</text>
	<text x=10 y=140 fill="#A20E58" onclick="shape()">shape</text>
	<text x=10 y=155 fill="#A20E58" onclick="texture()">texture</text>
	<text x=10 y=200 fill="#20B2AA" onclick="area()">AREA</text>
	<text x=10 y=220 fill="#20B2AA" onclick="size_area()">size</text>
	<text x=10 y=235 fill="#20B2AA" onclick="value_area()">value</text>
	<text x=10 y=250 fill="#20B2AA" onclick="orientation_area()">orientation</text>
	<text x=10 y=265 fill="#20B2AA" onclick="color_area()">color</text>
	<text x=10 y=280 fill="#20B2AA" onclick="shape_area()">shape</text>
	<text x=10 y=295 fill="#20B2AA" onclick="texture_area()">texture</text>
	<text x=10 y=35 fill="black" onclick="map()">US MAP</text>


</svg>

<svg width="960" height="500" id="svg2">
	<text x=200 y=30 fill="#A20E58" onclick="population()">show POPULATION barchart</text>
	<text x=200 y=70 fill="#2E8B57" onclick="area()">show AREA barchart</text>
</svg>

<svg height="10" width="10" xmlns="http://www.w3.org/2000/svg" version="1.1">
	<defs>
		<pattern id="circles-1" patternUnits="userSpaceOnUse" width="10" height="10">
			<image
				xlink:href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScxMCcgaGVpZ2h0PScxMCc+CiAgPHJlY3Qgd2lkdGg9JzEwJyBoZWlnaHQ9JzEwJyBmaWxsPSJ3aGl0ZSIgLz4KICA8Y2lyY2xlIGN4PSIxIiBjeT0iMSIgcj0iMSIgZmlsbD0iYmxhY2siLz4KPC9zdmc+"
				x="0" y="0" width="10" height="10"> </image>
		</pattern>
	</defs>
</svg>

<body>



	</svg>


	<script>
		var margin = {
				top: 20,
				right: 80,
				bottom: 20,
				left: 80
			},
			width = 960 - margin.left - margin.right,
			height = 500 - margin.top - margin.bottom;

		var svg1 = d3.select("#svg1").append("svg")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		var svg2 = d3.select("#svg2").append("svg")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");


		map();

		function map() {
			d3.select("#svg1").selectAll(".legend").remove();
			d3.select("#svg1").selectAll("circle").remove();
			d3.select("#svg1").selectAll(".point").remove();
			d3.select("#svg1").selectAll("path").remove();
			var margin = {
					top: 20,
					right: 80,
					bottom: 20,
					left: 80
				},
				width = 960 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			var svg1 = d3.select("#svg1").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var svg2 = d3.select("#svg2").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");


			d3.json("usa_mainland.json", drawUSA);

			function drawUSA(error, states) {

				var projection = d3.geoAlbersUsa()
					.translate([width / 2, height / 2]) // translate to center of screen
					.scale([1000]); // scale things down so see entire US

				// Define path generator
				var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
					.projection(projection);
				var geoGenerator = d3.geoPath()
					.projection(projection);

				svg1.selectAll("path")
					.data(states.features)
					.enter()
					.append("path")
					.attr("d", path)
					.attr("id", function(d) {
						return d.properties.STUSPS10;
					})
					.style("stroke", "black")
					.style("stroke-width", "1");


				svg1.selectAll('text')
					.data(states.features)
					.enter()
					.append('text')
					.attr('text-anchor', 'middle')
					.attr('alignment-baseline', 'middle')
					.attr('opacity', 0.5)
					.text(function(d) {
						return d.properties.STUSPS10;
					})
					.attr('transform', function(d) {
						var center = geoGenerator.centroid(d);
						return 'translate (' + center + ')';
					});
			}
		}

		population();

		function population() {
			var x = d3.scaleBand()
				.rangeRound([0, width])
				.paddingInner(0.05);;

			var y = d3.scaleLinear()
				.rangeRound([height, 0]);
			var tooltip = d3.select("body").append("div").attr("class", "toolTip");
			svg2.selectAll('rect').remove();
			svg2.selectAll('text').remove();
			d3.csv("population.csv", function(error, data) {
				if (error) {
					console.log(error)
				};
				console.log(data);
				data.forEach(function(d) {
					d.population = +d.population;
				});

				x.domain(data.map(function(d) {
					return d.State;
				}));
				y.domain([0, d3.max(data, function(d) {
					return d.population;
				})]);


				svg2.selectAll(".bar")
					.data(data)
					.enter().append("rect")
					.attr("class", "bar")
					.attr("x", function(d) {
						return x(d.State);
					})
					.attr("width", x.bandwidth())
					.attr("y", function(d) {
						return y(d.population);
					})
					.attr("height", function(d) {
						return height - y(d.population);
					})
					.attr("fill", "#A20E58")
					.on("mousemove", function(d) {
						tooltip
							.style("left", d3.event.pageX - 50 + "px")
							.style("top", d3.event.pageY - 70 + "px")
							.style("display", "inline-block")
							.html(("population:" + (d.population)));
						d3.select("#svg1").select("path#" + d.State).style("stroke", "orange").style("stroke-width", "5");

					})
					.on("mouseout", function(d) {
						tooltip.style("display", "none");
						d3.select("#svg1").selectAll('path').style("stroke", 'black').style("stroke-width", "1");
					});

				svg2.append("g")
					.attr("transform", "translate(0," + height + ")")
					.call(d3.axisBottom(x));
				svg2.append("g")
					.call(d3.axisLeft(y));
				svg2.append("text")
					.attr("transform", "rotate(-90)")
					.attr("y", 0 - margin.left)
					.attr("x", 0 - (height / 2))
					.attr("dy", "1em")
					.style("text-anchor", "middle")
					.text("Population");
				svg2.append("text")
					.attr("y", height)
					.attr("x", 900 - margin.right)
					.attr("dy", "1em")
					.style("text-anchor", "middle")
					.text("State");


			});
		}

		function area() {
			var x = d3.scaleBand()
				.rangeRound([0, width])
				.paddingInner(0.05);;

			var y = d3.scaleLinear()
				.rangeRound([height, 0]);
			var tooltip = d3.select("body").append("div").attr("class", "toolTip");
			svg2.selectAll('rect').remove();
			svg2.selectAll('text').remove();
			d3.csv("population.csv", function(error, data) {
				if (error) {
					console.log(error)
				};
				console.log(data);
				data.forEach(function(d) {
					d.area = +d.area;
				});

				x.domain(data.map(function(d) {
					return d.State;
				}));
				y.domain([0, d3.max(data, function(d) {
					return d.area;
				})]);


				svg2.selectAll(".bar")
					.data(data)
					.enter().append("rect")
					.attr("class", "bar")
					.attr("x", function(d) {
						return x(d.State);
					})
					.attr("width", x.bandwidth())
					.attr("y", function(d) {
						return y(d.area);
					})
					.attr("height", function(d) {
						return height - y(d.area);
					})
					.attr("fill", "#2E8B57")
					.on("mousemove", function(d) {
						tooltip
							.style("left", d3.event.pageX - 50 + "px")
							.style("top", d3.event.pageY - 70 + "px")
							.style("display", "inline-block")
							.html(("area:" + (d.area) + "</br>" + "square kilometers"));
						d3.select("#svg1").select("path#" + d.State).style("stroke", "orange").style("stroke-width", "5");

					})

					.on("mouseout", function(d) {
						tooltip.style("display", "none");
						d3.select("#svg1").selectAll('path').style("stroke", 'black').style("stroke-width", "1");
					});

				svg2.append("g")
					.attr("transform", "translate(0," + height + ")")
					.call(d3.axisBottom(x));
				svg2.append("g")
					.call(d3.axisLeft(y));
				svg2.append("text")
					.attr("transform", "rotate(-90)")
					.attr("y", 0 - margin.left)
					.attr("x", 0 - (height / 2))
					.attr("dy", "1em")
					.style("text-anchor", "middle")
					.text("Area (sq km)");
				svg2.append("text")
					.attr("y", height)
					.attr("x", 900 - margin.right)
					.attr("dy", "1em")
					.style("text-anchor", "middle")
					.text("State");


			});
		}

		function value() {
			d3.select("#svg1").selectAll(".legend").remove();
			d3.select("#svg1").selectAll("circle").remove();
			d3.select("#svg1").selectAll(".point").remove();
			d3.select("#svg1").selectAll("path").remove();
			var margin = {
					top: 20,
					right: 80,
					bottom: 20,
					left: 80
				},
				width = 960 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			var svg1 = d3.select("#svg1").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var lowColor = '#e8e8e8'
			var highColor = '#000000'
			var projection = d3.geoAlbersUsa()
				.translate([width / 2, height / 2]) // translate to center of screen
				.scale([1000]); // scale things down so see entire US

			// Define path generator
			var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
				.projection(projection);
			var geoGenerator = d3.geoPath()
				.projection(projection);


			d3.csv("population.csv", function(data) {
				var dataArray = [];
				for (var d = 0; d < data.length; d++) {
					dataArray.push(parseFloat(data[d].population))
				}
				var minVal = d3.min(dataArray)
				var maxVal = d3.max(dataArray)
				var ramp = d3.scaleLinear().domain([minVal, maxVal]).range([lowColor, highColor])

				// Load GeoJSON data and merge with states data
				d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
					for (var i = 0; i < data.length; i++) {

						// Grab State Name
						var dataState = data[i].State;

						// Grab data value
						var dataValue = data[i].population;

						// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

								// Copy the data value into the JSON
								json.features[j].properties.value = dataValue;

								// Stop looking through the JSON
								break;
								console.log(dataValue)
							}
						}
					}

					// Bind the data to the SVG and create one path per GeoJSON feature

					svg1.selectAll("path")
						.data(json.features)
						.enter()
						.append("path")
						.attr("d", path)
						.attr("id", function(d) {
							return d.properties.STUSPS10;
						})
						.style("stroke", "black")
						.style("stroke-width", "1")
						.style("fill", function(d) {
							return ramp(d.properties.value)
						});

					svg1.selectAll('text')
						.data(json.features)
						.enter()
						.append('text')
						.attr('text-anchor', 'middle')
						.attr('alignment-baseline', 'middle')
						.attr('opacity', 0.5)
						.attr('fill', '#A20E58')
						.attr('font-weight', 'bold')
						.text(function(d) {
							return d.properties.STUSPS10;
						})
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						});

					var key = d3.select("#svg1")
						.append("svg")
						.attr("width", 140)
						.attr("height", 300)
						.attr("x", 800)
						.attr("y", 300)
						.attr("class", "legend");

					var legend = key.append("defs")
						.append("svg:linearGradient")
						.attr("class", "legend")
						.attr("id", "gradient")
						.attr("x1", "100%")
						.attr("y1", "0%")
						.attr("x2", "100%")
						.attr("y2", "100%")
						.attr("spreadMethod", "pad");

					legend.append("stop")
						.attr("offset", "0%")
						.attr("stop-color", highColor)
						.attr("stop-opacity", 1);

					legend.append("stop")
						.attr("offset", "100%")
						.attr("stop-color", lowColor)
						.attr("stop-opacity", 1);

					key.append("rect")
						.attr("width", 40)
						.attr("height", 150)
						.style("fill", "url(#gradient)")
						.attr("transform", "translate(0,10)");

					var y = d3.scaleLinear()
						.range([150, 0])
						.domain([minVal, maxVal]);

					var yAxis = d3.axisRight(y);

					key.append("g")
						.attr("class", "y axis")
						.attr("transform", "translate(41,10)")
						.call(yAxis)


				});
			});
		}

		function color() {
			d3.select("#svg1").selectAll(".legend").remove();
			d3.select("#svg1").selectAll("path").remove();
			d3.select("#svg1").selectAll("rect#legend").remove();
			d3.select("#svg1").selectAll("text#legend").remove();
			var margin = {
					top: 20,
					right: 80,
					bottom: 20,
					left: 80
				},
				width = 960 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			var svg1 = d3.select("#svg1").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var projection = d3.geoAlbersUsa()
				.translate([width / 2, height / 2]) // translate to center of screen
				.scale([1000]); // scale things down so see entire US

			// Define path generator
			var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
				.projection(projection);
			var geoGenerator = d3.geoPath()
				.projection(projection);


			d3.csv("population.csv", function(data) {
				var dataArray = [];
				for (var d = 0; d < data.length; d++) {
					dataArray.push(parseFloat(data[d].population))
				}

				// Load GeoJSON data and merge with states data
				d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
					for (var i = 0; i < data.length; i++) {

						// Grab State Name
						var dataState = data[i].State;

						// Grab data value
						var dataValue = data[i].population;

						// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

								// Copy the data value into the JSON
								json.features[j].properties.value = dataValue;

								// Stop looking through the JSON
								break;
								console.log(dataValue)
							}
						}
					}
					svg1.selectAll("path")
						.data(json.features)
						.enter()
						.append("path")
						.attr("d", path)
						.attr("id", function(d) {
							return d.properties.STUSPS10;
						})
						.style("stroke", "black")
						.style("stroke-width", "1")
						.style("fill", function(d) {
							if (d.properties.value <= 2500000) {
								return "#60BDBF"
							} else if ((d.properties.value > 2500000) & (d.properties.value <= 5000000)) {
								return "#9CCD60";
							} else if ((d.properties.value > 5000000) & (d.properties.value <= 15000000)) {
								return "#ffcc66";
							} else if ((d.properties.value > 15000000) & (d.properties.value <= 24000000)) {
								return "cc6633";
							} else if (d.properties.value > 24000000) {
								return "#CC6699";
							}
						});
					var color = ["#60BDBF", "#9CCD60", "#ffcc66", "cc6633", "#CC6699"];
					var population = ["<=2.5M", "2.5M-5M", "5M-15M", "15M-24M", ">=24M	"];
					var data_l = [1, 2, 3, 4, 5];

					svg1.selectAll('text')
						.data(json.features)
						.enter()
						.append('text')
						.attr('text-anchor', 'middle')
						.attr('alignment-baseline', 'middle')
						.attr('opacity', 0.5)
						.text(function(d) {
							return d.properties.STUSPS10;
						})
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						});

					var legend = svg1.selectAll(".legend")
						.data(data_l, function(d, i) {
							return d + i;
						})
						.enter().append("g")
						.attr("class", "legend")
						.attr("transform", function(d, i) {
							return "translate(0," + i * 20 + ")";
						});

					legend.append("rect")
						.attr("x", width - 100)
						.attr("y", height - 108)
						.attr("width", 18)
						.attr("height", 18)
						.style("fill", function(d, i) {
							return color[i];
						});

					legend.append("text")
						.attr("x", width - 80)
						.attr("y", height - 100)
						.attr("dy", ".35em")
						.style("text-anchor", "start")
						.text(function(d, i) {
							return population[i];
						});


				});
			});
		}

		function size() {
			d3.select("#svg1").selectAll(".legend").remove();
			d3.select("#svg1").selectAll("circle").remove();
			d3.select("#svg1").selectAll(".point").remove();
			d3.select("#svg1").selectAll("path").remove();
			var radius = d3.scaleSqrt()
				.domain([0, 1e6])
				.range([0, 5]);

			var margin = {
					top: 20,
					right: 80,
					bottom: 20,
					left: 80
				},
				width = 960 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			var svg1 = d3.select("#svg1").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var projection = d3.geoAlbersUsa()
				.translate([width / 2, height / 2]) // translate to center of screen
				.scale([1000]); // scale things down so see entire US

			// Define path generator
			var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
				.projection(projection);
			var geoGenerator = d3.geoPath()
				.projection(projection);


			d3.csv("population.csv", function(data) {
				var dataArray = [];
				for (var d = 0; d < data.length; d++) {
					dataArray.push(parseFloat(data[d].population))
				}

				// Load GeoJSON data and merge with states data
				d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
					for (var i = 0; i < data.length; i++) {

						// Grab State Name
						var dataState = data[i].State;

						// Grab data value
						var dataValue = data[i].population;

						// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

								// Copy the data value into the JSON
								json.features[j].properties.value = dataValue;

								// Stop looking through the JSON
								break;
								console.log(dataValue)
							}
						}
					}

					// Bind the data to the SVG and create one path per GeoJSON feature

					svg1.selectAll("path")
						.data(json.features)
						.enter()
						.append("path")
						.attr("d", path)
						.attr("id", function(d) {
							return d.properties.STUSPS10;
						})
						.style("stroke", "black")
						.style("stroke-width", "1")

					svg1.append("g")
						.attr("class", "bubble")
						.selectAll("circle")
						.data(json.features)
						.enter().append("circle")
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						})
						.attr("r", function(d) {
							return radius(d.properties.value);
						})
						.attr("fill", "#A20E58");

				});
			});
		}

		function shape() {
			d3.select("#svg1").selectAll(".legend").remove();
			d3.select("#svg1").selectAll("circle").remove();
			d3.select("#svg1").selectAll(".point").remove();
			d3.select("#svg1").selectAll("path").remove();
			var margin = {
					top: 20,
					right: 80,
					bottom: 20,
					left: 80
				},
				width = 960 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			var svg1 = d3.select("#svg1").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var projection = d3.geoAlbersUsa()
				.translate([width / 2, height / 2]) // translate to center of screen
				.scale([1000]); // scale things down so see entire US

			// Define path generator
			var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
				.projection(projection);
			var geoGenerator = d3.geoPath()
				.projection(projection);


			d3.csv("population.csv", function(data) {
				var dataArray = [];
				for (var d = 0; d < data.length; d++) {
					dataArray.push(parseFloat(data[d].population))
				}

				// Load GeoJSON data and merge with states data
				d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
					for (var i = 0; i < data.length; i++) {

						// Grab State Name
						var dataState = data[i].State;

						// Grab data value
						var dataValue = data[i].population;

						// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

								// Copy the data value into the JSON
								json.features[j].properties.value = dataValue;

								// Stop looking through the JSON
								break;
								console.log(dataValue)
							}
						}
					}

					// Bind the data to the SVG and create one path per GeoJSON feature

					svg1.selectAll("path")
						.data(json.features)
						.enter()
						.append("path")
						.attr("id", function(d) {
							return d.properties.STUSPS10;
						})
						.attr("d", path)
						.style("stroke", "black")
						.style("stroke-width", "1")


					svg1.selectAll(".point")
						.data(json.features)
						.enter()
						.append("path")
						.attr("d", path)
						.attr("d", d3.symbol()
							.size(100)
							.type(function(d) {
								if (d.properties.value <= 2500000) {
									return d3.symbolWye;
								} else if ((d.properties.value > 2500000) & (d.properties.value <= 5000000)) {
									return d3.symbolCross;
								} else if ((d.properties.value > 5000000) & (d.properties.value <= 15000000)) {
									return d3.symbolTriangle;
								} else if ((d.properties.value > 15000000) & (d.properties.value <= 24000000)) {
									return d3.symbolDiamond;
								} else if (d.properties.value > 24000000) {
									return d3.symbolStar;
								}
							}))
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						})
						.style("fill", "#A20E58")
						.style('stroke', 'black')
						.style('stoke-width', '1');

					var population = ["<=2.5M", "2.5M-5M", "5M-15M", "15M-24M", ">=24M	"];
					var data_l = [1, 2, 3, 4, 5];
					var symbolLegend = [d3.symbolWye, d3.symbolCross, d3.symbolTriangle, d3.symbolDiamond, d3.symbolStar];

					var legend = svg1.selectAll(".legend")
						.data(data_l, function(d, i) {
							return d + i;
						})
						.enter().append("g")
						.attr("class", "legend")
						.attr("transform", function(d, i) {
							return "translate(0," + i * 20 + ")";
						});


					var triangleU = d3.symbol().type(d3.symbolWye)(),
						circle = d3.symbol().type(d3.symbolCross)(),
						cross = d3.symbol().type(d3.symbolTriangle)(),
						diamond = d3.symbol().type(d3.symbolDiamond)(),
						star = d3.symbol().type(d3.symbolStar)();

					var symbolScale = d3.scaleOrdinal()
						.domain(population)
						.range([triangleU, circle, cross, diamond, star]);

					var svg = d3.select("#svg1")
						.append("svg")
						.attr("width", 140)
						.attr("height", 300)
						.attr("x", 760)
						.attr("y", 350)
						.attr("class", "legend");


					svg.append("g")
						.attr("class", "legend")
						.attr("transform", "translate(20, 20)");

					var legendPath = d3.legendSymbol()
						.scale(symbolScale)
						.orient("vertical")
						.labelWrap(100);

					svg.select(".legend")
						.call(legendPath);


				});
			});
		}

		function texture() {
			d3.select("#svg1").selectAll(".legend").remove();
			d3.select("#svg1").selectAll("circle").remove();
			d3.select("#svg1").selectAll(".point").remove();
			d3.select("#svg1").selectAll("path").remove();

			var margin = {
					top: 20,
					right: 80,
					bottom: 20,
					left: 80
				},
				width = 960 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			var svg1 = d3.select("#svg1").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var orange = '#ff8c00',
				navy = '#0d3268';

			// defined textures
			var t5 = textures.lines()
				.orientation("6/8");

			var t3 = textures.paths()
				.d("crosses")
				.lighter()
				.thicker();

			var t4 = textures.paths()
				.d("hexagons")
				.size(8)
				.strokeWidth(2);

			var t2 = textures.circles()
				.size(10)
				.radius(1.5);
			var t1 = textures.paths()
				.d("waves")
				.thicker();

			// add all textures to an array
			var tlist = [t1, t2, t3, t4, t5];

			var projection = d3.geoAlbersUsa()
				.translate([width / 2, height / 2]) // translate to center of screen
				.scale([1000]); // scale things down so see entire US

			// Define path generator
			var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
				.projection(projection);
			var geoGenerator = d3.geoPath()
				.projection(projection);


			d3.csv("population.csv", function(data) {
				var dataArray = [];
				for (var d = 0; d < data.length; d++) {
					dataArray.push(parseFloat(data[d].population))
				}

				// Load GeoJSON data and merge with states data
				d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
					for (var i = 0; i < data.length; i++) {

						// Grab State Name
						var dataState = data[i].State;

						// Grab data value
						var dataValue = data[i].population;

						// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

								// Copy the data value into the JSON
								json.features[j].properties.value = dataValue;

								// Stop looking through the JSON
								break;
								console.log(dataValue)
							}
						}
					}
					tlist.forEach(function(t) {
						svg1.call(t);
					});

					svg1.selectAll("path")
						.data(json.features, function(d, i) {
							return d + i;
						})
						.enter()
						.append("path")
						.attr("d", path)
						.attr("id", function(d) {
							return d.properties.STUSPS10;
						})
						.style("stroke", "#000")
						.style("stroke-width", "1")
						.style("fill", function(d) {
							if (d.properties.value <= 2500000) {
								return t1.url();
							} else if ((d.properties.value > 2500000) & (d.properties.value <= 5000000)) {
								return t4.url();
							} else if ((d.properties.value > 5000000) & (d.properties.value <= 15000000)) {
								return t3.url();
							} else if ((d.properties.value > 15000000) & (d.properties.value <= 24000000)) {
								return t2.url();
							} else if (d.properties.value > 24000000) {
								return t5.url();
							}
						});


					svg1.selectAll('text')
						.data(json.features)
						.enter()
						.append('text')
						.attr('text-anchor', 'middle')
						.attr('alignment-baseline', 'middle')
						.attr('opacity', 0.5)
						.text(function(d) {
							return d.properties.STUSPS10;
						})
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						});
					var population = ["<=2.5M", "2.5M-5M", "5M-15M", "15M-24M", ">=24M	"];
					var data_l = [1, 2, 3, 4, 5];
					var legend = svg1.selectAll(".legend")
						.data(data_l, function(d, i) {
							return d + i;
						})
						.enter().append("g")
						.attr("class", "legend")
						.attr("transform", function(d, i) {
							return "translate(0," + i * 20 + ")";
						});

					legend.append("rect")
						.attr("id", "legend")
						.attr("x", width - 100)
						.attr("y", height - 108)
						.attr("width", 18)
						.attr("height", 18)
						.style("fill", function(d, i) {
							return tlist[i].url();
						})
						.style("stroke", "#000")
						.style("stroke-width", "1");

					legend.append("text")
						.attr("id", "legend")
						.attr("x", width - 75)
						.attr("y", height - 100)
						.attr("dy", ".35em")
						.style("text-anchor", "start")
						.text(function(d, i) {
							return population[i];
						});

				});
			});
		}

		function orientation() {
			d3.select("#svg1").selectAll(".legend").remove();
			d3.select("#svg1").selectAll("circle").remove();
			d3.select("#svg1").selectAll(".point").remove();
			d3.select("#svg1").selectAll("path").remove();

			var margin = {
					top: 20,
					right: 80,
					bottom: 20,
					left: 80
				},
				width = 960 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			var svg1 = d3.select("#svg1").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			// defined textures
			var t1 = textures.lines()
				.thicker()
				.orientation("horizontal");
			var t2 = textures.lines()
				.thicker()
				.orientation("1/8");
			var t3 = textures.lines()
				.thicker()
				.orientation("2/8");
			var t4 = textures.lines()
				.thicker()
				.orientation("3/8");
			var t5 = textures.lines()
				.thicker()
				.orientation("5/8");
			var t6 = textures.lines()
				.thicker()
				.orientation("5/8");
			var t7 = textures.lines()
				.thicker()
				.orientation("6/8");
			var t8 = textures.lines()
				.thicker()
				.orientation("7/8");
			var t9 = textures.lines()
				.thicker()
				.orientation("vertical");
			// add all textures to an array
			var tlist = [t1, t2, t3, t4, t5, t6, t7, t8, t9];

			var projection = d3.geoAlbersUsa()
				.translate([width / 2, height / 2]) // translate to center of screen
				.scale([1000]); // scale things down so see entire US

			// Define path generator
			var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
				.projection(projection);
			var geoGenerator = d3.geoPath()
				.projection(projection);


			d3.csv("population.csv", function(data) {
				var dataArray = [];
				for (var d = 0; d < data.length; d++) {
					dataArray.push(parseFloat(data[d].population))
				}

				// Load GeoJSON data and merge with states data
				d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
					for (var i = 0; i < data.length; i++) {

						// Grab State Name
						var dataState = data[i].State;

						// Grab data value
						var dataValue = data[i].population;

						// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

								// Copy the data value into the JSON
								json.features[j].properties.value = dataValue;

								// Stop looking through the JSON
								break;
								console.log(dataValue)
							}
						}
					}
					tlist.forEach(function(t) {
						svg1.call(t);
					});

					svg1.selectAll("path")
						.data(json.features, function(d, i) {
							return d + i;
						})
						.enter()
						.append("path")
						.attr("d", path)
						.attr("id", function(d) {
							return d.properties.STUSPS10;
						})
						.style("stroke", "#000")
						.style("stroke-width", "1")
						.style("fill", function(d) {
							if (d.properties.value <= 2500000) {
								return t1.url();
							} else if ((d.properties.value > 2500000) & (d.properties.value <= 5000000)) {
								return t2.url();
							} else if ((d.properties.value > 5000000) & (d.properties.value <= 15000000)) {
								return t3.url();
							} else if ((d.properties.value > 15000000) & (d.properties.value <= 24000000)) {
								return t4.url();
							} else if (d.properties.value > 24000000) {
								return t5.url();
							}
						});

					svg1.selectAll('text')
						.data(json.features)
						.enter()
						.append('text')
						.attr('text-anchor', 'middle')
						.attr('alignment-baseline', 'middle')
						.attr('opacity', 0.5)
						.text(function(d) {
							return d.properties.STUSPS10;
						})
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						});

					var population = ["<=2.5M", "2.5M-5M", "5M-15M", "15M-24M", ">=24M	"];
					var data_l = [1, 2, 3, 4, 5];
					var legend = svg1.selectAll(".legend")
						.data(data_l, function(d, i) {
							return d + i;
						})
						.enter().append("g")
						.attr("class", "legend")
						.attr("transform", function(d, i) {
							return "translate(0," + i * 20 + ")";
						});

					legend.append("rect")
						.attr("x", width - 100)
						.attr("y", height - 108)
						.attr("id", "legend")
						.attr("width", 18)
						.attr("height", 18)
						.style("fill", function(d, i) {
							return tlist[i].url();
						})
						.style("stroke", "#000")
						.style("stroke-width", "1");

					legend.append("text")
						.attr("x", width - 75)
						.attr("y", height - 100)
						.attr("id", "legend")
						.attr("dy", ".35em")
						.style("text-anchor", "start")
						.text(function(d, i) {
							return population[i];
						});

				});
			});
		}




		function value_area() {
			d3.select("#svg1").selectAll(".legend").remove();
			d3.select("#svg1").selectAll("circle").remove();
			d3.select("#svg1").selectAll(".point").remove();
			d3.select("#svg1").selectAll("path").remove();

			var margin = {
					top: 20,
					right: 80,
					bottom: 20,
					left: 80
				},
				width = 960 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			var svg1 = d3.select("#svg1").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var lowColor = '#e8e8e8'
			var highColor = '#000000'
			var projection = d3.geoAlbersUsa()
				.translate([width / 2, height / 2]) // translate to center of screen
				.scale([1000]); // scale things down so see entire US

			// Define path generator
			var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
				.projection(projection);
			var geoGenerator = d3.geoPath()
				.projection(projection);


			d3.csv("population.csv", function(data) {
				var dataArray = [];
				for (var d = 0; d < data.length; d++) {
					dataArray.push(parseFloat(data[d].area))
				}
				var minVal = d3.min(dataArray)
				var maxVal = d3.max(dataArray)
				var ramp = d3.scaleLinear().domain([minVal, maxVal]).range([lowColor, highColor])

				// Load GeoJSON data and merge with states data
				d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
					for (var i = 0; i < data.length; i++) {

						// Grab State Name
						var dataState = data[i].State;

						// Grab data value
						var dataValue = data[i].area;

						// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

								// Copy the data value into the JSON
								json.features[j].properties.value = dataValue;

								// Stop looking through the JSON
								break;
								console.log(dataValue)
							}
						}
					}

					// Bind the data to the SVG and create one path per GeoJSON feature

					svg1.selectAll("path")
						.data(json.features)
						.enter()
						.append("path")
						.attr("d", path)
						.attr("id", function(d) {
							return d.properties.STUSPS10;
						})
						.style("stroke", "black")
						.style("stroke-width", "1")
						.style("fill", function(d) {
							return ramp(d.properties.value)
						});

					svg1.selectAll('text')
						.data(json.features)
						.enter()
						.append('text')
						.attr('fill', '#087851')
						.attr('font-weight', 'bold')
						.attr('text-anchor', 'middle')
						.attr('alignment-baseline', 'middle')
						.attr('opacity', 0.5)
						.text(function(d) {
							return d.properties.STUSPS10;
						})
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						});

					var key = d3.select("#svg1")
						.append("svg")
						.attr("width", 140)
						.attr("height", 300)
						.attr("x", 800)
						.attr("y", 300)
						.attr("class", "legend");

					var legend = key.append("defs")
						.append("svg:linearGradient")
						.attr("class", "legend")
						.attr("id", "gradient")
						.attr("x1", "100%")
						.attr("y1", "0%")
						.attr("x2", "100%")
						.attr("y2", "100%")
						.attr("spreadMethod", "pad");

					legend.append("stop")
						.attr("offset", "0%")
						.attr("stop-color", highColor)
						.attr("stop-opacity", 1);

					legend.append("stop")
						.attr("offset", "100%")
						.attr("stop-color", lowColor)
						.attr("stop-opacity", 1);

					key.append("rect")
						.attr("width", 40)
						.attr("height", 150)
						.style("fill", "url(#gradient)")
						.attr("transform", "translate(0,10)");

					var y = d3.scaleLinear()
						.range([150, 0])
						.domain([minVal, maxVal]);

					var yAxis = d3.axisRight(y);

					key.append("g")
						.attr("class", "y axis")
						.attr("transform", "translate(41,10)")
						.call(yAxis)

				});
			});
		}

		function color_area() {
			d3.select("#svg1").selectAll(".legend").remove();
			d3.select("#svg1").selectAll("circle").remove();
			d3.select("#svg1").selectAll(".point").remove();
			d3.select("#svg1").selectAll("path").remove();

			var margin = {
					top: 20,
					right: 80,
					bottom: 20,
					left: 80
				},
				width = 960 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			var svg1 = d3.select("#svg1").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var projection = d3.geoAlbersUsa()
				.translate([width / 2, height / 2]) // translate to center of screen
				.scale([1000]); // scale things down so see entire US

			// Define path generator
			var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
				.projection(projection);
			var geoGenerator = d3.geoPath()
				.projection(projection);


			d3.csv("population.csv", function(data) {
				var dataArray = [];
				for (var d = 0; d < data.length; d++) {
					dataArray.push(parseFloat(data[d].area))
				}

				// Load GeoJSON data and merge with states data
				d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
					for (var i = 0; i < data.length; i++) {

						// Grab State Name
						var dataState = data[i].State;

						// Grab data value
						var dataValue = data[i].area;

						// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

								// Copy the data value into the JSON
								json.features[j].properties.value = dataValue;

								// Stop looking through the JSON
								break;
								console.log(dataValue)
							}
						}
					}

					// Bind the data to the SVG and create one path per GeoJSON feature

					svg1.selectAll("path")
						.data(json.features)
						.enter()
						.append("path")
						.attr("d", path)
						.attr("id", function(d) {
							return d.properties.STUSPS10;
						})
						.style("stroke", "black")
						.style("stroke-width", "1")
						.style("fill", function(d) {
							if (d.properties.value <= 100000) {
								return "#60BDBF"
							} else if ((d.properties.value > 100000) & (d.properties.value <= 200000)) {
								return "#9CCD60";
							} else if ((d.properties.value > 200000) & (d.properties.value <= 300000)) {
								return "#ffcc66";
							} else if ((d.properties.value > 300000) & (d.properties.value <= 400000)) {
								return "cc6633";
							} else if (d.properties.value > 400000) {
								return "#CC6699";
							}
						});

					svg1.selectAll('text')
						.data(json.features)
						.enter()
						.append('text')
						.attr('text-anchor', 'middle')
						.attr('alignment-baseline', 'middle')
						.attr('opacity', 0.5)
						.text(function(d) {
							return d.properties.STUSPS10;
						})
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						});
					var color = ["#60BDBF", "#9CCD60", "#ffcc66", "cc6633", "#CC6699"];
					var area = ["<=0.1M sq km", "0.1M-0.2M", "0.2M-0.3M", "0.3M-0.4M", ">=0.4M	"];
					var data_l = [1, 2, 3, 4, 5];

					var legend = svg1.selectAll(".legend")
						.data(data_l, function(d, i) {
							return d + i;
						})
						.enter().append("g")
						.attr("class", "legend")
						.attr("transform", function(d, i) {
							return "translate(0," + i * 20 + ")";
						});

					legend.append("rect")
						.attr("x", width - 100)
						.attr("y", height - 108)
						.attr("width", 18)
						.attr("height", 18)
						.style("fill", function(d, i) {
							return color[i];
						});

					legend.append("text")
						.attr("x", width - 80)
						.attr("y", height - 100)
						.attr("dy", ".35em")
						.style("text-anchor", "start")
						.text(function(d, i) {
							return area[i];
						});



				});
			});
		}

		function size_area() {
			d3.select("#svg1").selectAll(".legend").remove();
			d3.select("#svg1").selectAll("circle").remove();
			d3.select("#svg1").selectAll(".point").remove();
			d3.select("#svg1").selectAll("path").remove();
			var radius = d3.scaleSqrt()
				.domain([0, 1730000])
				.range([0, 40]);

			var margin = {
					top: 20,
					right: 80,
					bottom: 20,
					left: 80
				},
				width = 960 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			var svg1 = d3.select("#svg1").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var projection = d3.geoAlbersUsa()
				.translate([width / 2, height / 2]) // translate to center of screen
				.scale([1000]); // scale things down so see entire US

			// Define path generator
			var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
				.projection(projection);
			var geoGenerator = d3.geoPath()
				.projection(projection);


			d3.csv("population.csv", function(data) {
				var dataArray = [];
				for (var d = 0; d < data.length; d++) {
					dataArray.push(parseFloat(data[d].area))
				}

				// Load GeoJSON data and merge with states data
				d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
					for (var i = 0; i < data.length; i++) {

						// Grab State Name
						var dataState = data[i].State;

						// Grab data value
						var dataValue = data[i].area;

						// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

								// Copy the data value into the JSON
								json.features[j].properties.value = dataValue;

								// Stop looking through the JSON
								break;
								console.log(dataValue)
							}
						}
					}

					// Bind the data to the SVG and create one path per GeoJSON feature

					svg1.selectAll("path")
						.data(json.features)
						.enter()
						.append("path")
						.attr("d", path)
						.attr("id", function(d) {
							return d.properties.STUSPS10;
						})
						.style("stroke", "black")
						.style("stroke-width", "1")

					svg1.append("g")
						.attr("class", "bubble")
						.selectAll("circle")
						.data(json.features)
						.enter().append("circle")
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						})
						.attr("r", function(d) {
							return radius(d.properties.value);
						})
						.attr("fill", "#2E8B57");

				});
			});
		}

		function shape_area() {
			d3.select("#svg1").selectAll(".legend").remove();
			d3.select("#svg1").selectAll("circle").remove();
			d3.select("#svg1").selectAll(".point").remove();
			d3.select("#svg1").selectAll("path").remove();
			var margin = {
					top: 20,
					right: 80,
					bottom: 20,
					left: 80
				},
				width = 960 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			var svg1 = d3.select("#svg1").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var projection = d3.geoAlbersUsa()
				.translate([width / 2, height / 2]) // translate to center of screen
				.scale([1000]); // scale things down so see entire US

			// Define path generator
			var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
				.projection(projection);
			var geoGenerator = d3.geoPath()
				.projection(projection);


			d3.csv("population.csv", function(data) {
				var dataArray = [];
				for (var d = 0; d < data.length; d++) {
					dataArray.push(parseFloat(data[d].area))
				}

				// Load GeoJSON data and merge with states data
				d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
					for (var i = 0; i < data.length; i++) {

						// Grab State Name
						var dataState = data[i].State;

						// Grab data value
						var dataValue = data[i].area;

						// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

								// Copy the data value into the JSON
								json.features[j].properties.value = dataValue;

								// Stop looking through the JSON
								break;
								console.log(dataValue)
							}
						}
					}

					// Bind the data to the SVG and create one path per GeoJSON feature

					svg1.selectAll("path")
						.data(json.features)
						.enter()
						.append("path")
						.attr("d", path)
						.attr("id", function(d) {
							return d.properties.STUSPS10;
						})
						.style("stroke", "black")
						.style("stroke-width", "1")


					svg1.selectAll(".point")
						.data(json.features)
						.enter()
						.append("path")
						.attr("d", path)
						.attr("d", d3.symbol()
							.size(100)
							.type(function(d) {
								if (d.properties.value <= 100000) {
									return d3.symbolWye;
								} else if ((d.properties.value > 100000) & (d.properties.value <= 200000)) {
									return d3.symbolCross;
								} else if ((d.properties.value > 200000) & (d.properties.value <= 300000)) {
									return d3.symbolTriangle;
								} else if ((d.properties.value > 300000) & (d.properties.value <= 400000)) {
									return d3.symbolDiamond;
								} else if (d.properties.value > 400000) {
									return d3.symbolStar;
								}
							}))
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						})
						.style("fill", "#20B2AA")
						.style('stroke', 'black')
						.style('stoke-width', '1');
					var area = ["<=0.1M sq km", "0.1M-0.2M", "0.2M-0.3M", "0.3M-0.4M", ">=0.4M	"];
					var data_l = [1, 2, 3, 4, 5];
					var symbolLegend = [d3.symbolWye, d3.symbolCross, d3.symbolTriangle, d3.symbolDiamond, d3.symbolStar];

					var legend = svg1.selectAll(".legend")
						.data(data_l, function(d, i) {
							return d + i;
						})
						.enter().append("g")
						.attr("class", "legend")
						.attr("transform", function(d, i) {
							return "translate(0," + i * 20 + ")";
						});


					var triangleU = d3.symbol().type(d3.symbolWye)(),
						circle = d3.symbol().type(d3.symbolCross)(),
						cross = d3.symbol().type(d3.symbolTriangle)(),
						diamond = d3.symbol().type(d3.symbolDiamond)(),
						star = d3.symbol().type(d3.symbolStar)();

					var symbolScale = d3.scaleOrdinal()
						.domain(area)
						.range([triangleU, circle, cross, diamond, star]);

					var svg = d3.select("#svg1")
						.append("svg")
						.attr("width", 140)
						.attr("height", 300)
						.attr("x", 760)
						.attr("y", 350)
						.attr("class", "legend");

					svg.append("g")
						.attr("class", "legend")
						.attr("transform", "translate(20, 20)");

					var legendPath = d3.legendSymbol()
						.scale(symbolScale)
						.orient("vertical")
						.labelWrap(100);

					svg.select(".legend")
						.call(legendPath);


				});
			});
		}

		function texture_area() {
			d3.select("#svg1").selectAll(".legend").remove();
			d3.select("#svg1").selectAll("circle").remove();
			d3.select("#svg1").selectAll(".point").remove();
			d3.select("#svg1").selectAll("path").remove();

			var margin = {
					top: 20,
					right: 80,
					bottom: 20,
					left: 80
				},
				width = 960 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			var svg1 = d3.select("#svg1").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var orange = '#ff8c00',
				navy = '#0d3268';

			// defined textures
			var t5 = textures.lines()
				.orientation("6/8");

			var t3 = textures.paths().
			d("crosses")
				.lighter()
				.thicker();

			var t4 = textures.paths()
				.d("hexagons")
				.size(8)
				.strokeWidth(2);

			var t2 = textures.circles()
				.size(10)
				.radius(1.5);
			var t1 = textures.paths()
				.d("waves")
				.thicker();


			// add all textures to an array
			var tlist = [t1, t2, t3, t4, t5];

			var projection = d3.geoAlbersUsa()
				.translate([width / 2, height / 2]) // translate to center of screen
				.scale([1000]); // scale things down so see entire US

			// Define path generator
			var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
				.projection(projection);
			var geoGenerator = d3.geoPath()
				.projection(projection);


			d3.csv("population.csv", function(data) {
				var dataArray = [];
				for (var d = 0; d < data.length; d++) {
					dataArray.push(parseFloat(data[d].area))
				}

				// Load GeoJSON data and merge with states data
				d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
					for (var i = 0; i < data.length; i++) {

						// Grab State Name
						var dataState = data[i].State;

						// Grab data value
						var dataValue = data[i].area;

						// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

								// Copy the data value into the JSON
								json.features[j].properties.value = dataValue;

								// Stop looking through the JSON
								break;
								console.log(dataValue)
							}
						}
					}
					tlist.forEach(function(t) {
						svg1.call(t);
					});

					svg1.selectAll("path")
						.data(json.features, function(d, i) {
							return d + i;
						})
						.enter()
						.append("path")
						.attr("d", path)
						.attr("id", function(d) {
							return d.properties.STUSPS10;
						})
						.style("stroke", "#000")
						.style("stroke-width", "1")
						.style("fill", function(d) {
							if (d.properties.value <= 100000) {
								return t1.url();
							} else if ((d.properties.value > 100000) & (d.properties.value <= 200000)) {
								return t4.url();
							} else if ((d.properties.value > 200000) & (d.properties.value <= 300000)) {
								return t3.url();
							} else if ((d.properties.value > 300000) & (d.properties.value <= 400000)) {
								return t2.url();
							} else if (d.properties.value > 400000) {
								return t5.url();
							}
						});


					svg1.selectAll('text')
						.data(json.features)
						.enter()
						.append('text')
						.attr('text-anchor', 'middle')
						.attr('alignment-baseline', 'middle')
						.attr('opacity', 0.5)
						.text(function(d) {
							return d.properties.STUSPS10;
						})
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						});

					var area = ["<=0.1M sq km", "0.1M-0.2M", "0.2M-0.3M", "0.3M-0.4M", ">=0.4M	"];
					var data_l = [1, 2, 3, 4, 5];
					var legend = svg1.selectAll(".legend")
						.data(data_l, function(d, i) {
							return d + i;
						})
						.enter().append("g")
						.attr("class", "legend")
						.attr("transform", function(d, i) {
							return "translate(0," + i * 20 + ")";
						});

					legend.append("rect")
						.attr("x", width - 100)
						.attr("y", height - 108)
						.attr("id", "legend")
						.attr("width", 18)
						.attr("height", 18)
						.style("fill", function(d, i) {
							return tlist[i].url();
						})
						.style("stroke", "#000")
						.style("stroke-width", "1");

					legend.append("text")
						.attr("x", width - 75)
						.attr("y", height - 100)
						.attr("id", "legend")
						.attr("dy", ".35em")
						.style("text-anchor", "start")
						.text(function(d, i) {
							return area[i];
						});


				});
			});
		}


		function orientation_area() {
			d3.select("#svg1").selectAll(".legend").remove();
			d3.select("#svg1").selectAll("circle").remove();
			d3.select("#svg1").selectAll(".point").remove();
			d3.select("#svg1").selectAll("path").remove();
			var margin = {
					top: 20,
					right: 80,
					bottom: 20,
					left: 80
				},
				width = 960 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			var svg1 = d3.select("#svg1").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			// defined textures
			var t1 = textures.lines()
				.thicker()
				.orientation("horizontal");
			var t2 = textures.lines()
				.thicker()
				.orientation("1/8");
			var t3 = textures.lines()
				.thicker()
				.orientation("2/8");
			var t4 = textures.lines()
				.thicker()
				.orientation("3/8");
			var t5 = textures.lines()
				.thicker()
				.orientation("5/8");
			var t6 = textures.lines()
				.thicker()
				.orientation("5/8");
			var t7 = textures.lines()
				.thicker()
				.orientation("6/8");
			var t8 = textures.lines()
				.thicker()
				.orientation("7/8");
			var t9 = textures.lines()
				.thicker()
				.orientation("vertical");
			// add all textures to an array
			var tlist = [t1, t2, t3, t4, t5, t6, t7, t8, t9];

			var projection = d3.geoAlbersUsa()
				.translate([width / 2, height / 2]) // translate to center of screen
				.scale([1000]); // scale things down so see entire US

			// Define path generator
			var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
				.projection(projection);
			var geoGenerator = d3.geoPath()
				.projection(projection);


			d3.csv("population.csv", function(data) {
				var dataArray = [];
				for (var d = 0; d < data.length; d++) {
					dataArray.push(parseFloat(data[d].area))
				}

				// Load GeoJSON data and merge with states data
				d3.json("usa_mainland.json", function(json) {

					// Loop through each state data value in the .csv file
					for (var i = 0; i < data.length; i++) {

						// Grab State Name
						var dataState = data[i].State;

						// Grab data value
						var dataValue = data[i].area;

						// Find the corresponding state inside the GeoJSON
						for (var j = 0; j < json.features.length; j++) {
							var jsonState = json.features[j].properties.STUSPS10;

							if (dataState == jsonState) {

								// Copy the data value into the JSON
								json.features[j].properties.value = dataValue;

								// Stop looking through the JSON
								break;
								console.log(dataValue)
							}
						}
					}
					tlist.forEach(function(t) {
						svg1.call(t);
					});

					svg1.selectAll("path")
						.data(json.features, function(d, i) {
							return d + i;
						})
						.enter()
						.append("path")
						.attr("d", path)
						.attr("id", function(d) {
							return d.properties.STUSPS10;
						})
						.style("stroke", "#000")
						.style("stroke-width", "1")
						.style("fill", function(d) {
							if (d.properties.value <= 100000) {
								return t5.url();
							} else if ((d.properties.value > 100000) & (d.properties.value <= 200000)) {
								return t1.url();
							} else if ((d.properties.value > 200000) & (d.properties.value <= 300000)) {
								return t2.url();
							} else if ((d.properties.value > 300000) & (d.properties.value <= 400000)) {
								return t9.url();
							} else if (d.properties.value > 400000) {
								return t7.url();
							}
						});


					svg1.selectAll('text')
						.data(json.features)
						.enter()
						.append('text')
						.attr('text-anchor', 'middle')
						.attr('alignment-baseline', 'middle')
						.attr('opacity', 0.5)
						.text(function(d) {
							return d.properties.STUSPS10;
						})
						.attr('transform', function(d) {
							var center = geoGenerator.centroid(d);
							return 'translate (' + center + ')';
						});

					var area = ["<=0.1M sq km", "0.1M-0.2M", "0.2M-0.3M", "0.3M-0.4M", ">=0.4M	"];
					var data_l = [1, 2, 3, 4, 5];
					var legend = svg1.selectAll(".legend")
						.data(data_l, function(d, i) {
							return d + i;
						})
						.enter().append("g")
						.attr("class", "legend")
						.attr("transform", function(d, i) {
							return "translate(0," + i * 20 + ")";
						});

					legend.append("rect")
						.attr("x", width - 100)
						.attr("y", height - 108)
						.attr("id", "legend")
						.attr("width", 18)
						.attr("height", 18)
						.style("fill", function(d, i) {
							return tlist[i].url();
						})
						.style("stroke", "#000")
						.style("stroke-width", "1");

					legend.append("text")
						.attr("x", width - 75)
						.attr("y", height - 100)
						.attr("id", legend)
						.attr("dy", ".35em")
						.style("text-anchor", "start")
						.text(function(d, i) {
							return area[i];
						});

				});
			});
		}
	</script>

</html>
